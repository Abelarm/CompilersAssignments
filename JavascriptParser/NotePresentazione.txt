COSE CHE NON ABBIAMO FATTO

	Classi
	oggetti
	valutazioni regex
	template
	(PanicMode)

    non è proprio vero che non l'abbiamo fatto
    ma javascript sia la grammatica del lexer che quella del parser
    tratta i numeri decimali con virgola e non allo stesso modo
    mentre per ottale binario e esadecimale vengono visti come interi

    quindi per avere se è intero o floating controlliamo se dentro 
    la stringa del numero è contenuto un punto allora lo definiamo come floating
    altrimenti int

    recovery mode infattibile perchè dovremmo modificare tutta la grammatica
    e non abbiamo la capa
    provato con la schifezza SuperProduction
    ErrorStatement ::= SuperProduction ERROR

    ma sta cosa creatava un radoppio delle produzioni
    che creava una tavola delle produzioni che java si lamentava.

COSE OP CHE ABBIAMO FATTO

AGGIUNTA NODI LABEL PER SCRITTURA PIU' BELLA

AssignementExpression a mano = AssignmentExpression ::= IdentifierReference Initializer 
altrimenti assegnazioni dentro un block non andavano

a = b++; => a = b e b = b+1;
a = ++b; => b = b+1 e a = b;


conflitto 
Warning : *** Shift/Reduce conflict found in state #104
  between UnaryExpression ::= UpdateExpression (*) 
  and     ExponentiationExpression ::= UpdateExpression (*) STARSTAR ExponentiationExpression 
  under symbol STAR
  Resolved in favor of shifting.
a ** b
a * b
attraverso un nuovo token nel lexer

OPERATORE TERNARIO COME UN IF
CHE SI PUò concatenareeeee


WHILE => CONDIZIONE primo nodo - CORPO secondo nodo
DO WHILE => CORPO primo nood - CONDIZIONE secondo nodo


Contatore di Elision

Elision: COMMA
| Elision COMMA
;

per contare quanti elementi vuoti in un array js che è possibile fare



POssiamo accedere ad un arrray attravero l'espressione
in quanto il risultato di un assegnamento è il valore che assegniamo alla variabile
quindi esempio:
d=1
a[c=d++]
equivale ad accedere ad
a[1]
e poi eseguire d++

SOLUZIONE PIU' precisa ma complessa
MemberExpression
    ::= PrimaryExpression:pe
    {:
        RESULT = pe;
    :}
    | MemberExpression:me LSQPAR Expression:e RSQPAR
    {:
        Label source = new Label("Source", curr_lineno());
        source.addChild((Node)me);
        Label access = new Label("Access", curr_lineno());
        if(e instanceof ArrayList){
            ArrayList<Node> list = (ArrayList<Node>) e;
            Node e1 = list.get(0);
            Node e2 = list.get(1);
            access.addChild((Node)e1);
            ItemAccess ia = new ItemAccess(source, access, curr_lineno());
            list = new ArrayList<Node:angry:);
            list.add(ia);
            list.add(e2);
            RESULT = list;
        }
        else{
            access.addChild((Node)e);
            ItemAccess ia = new ItemAccess(source, access, curr_lineno());
            RESULT = ia;
        }
    :}


> a
10
> s = [1,2]
[ 1, 2 ]
> s[b=0]
1
> s[b=1]
2
> d = 0
0
> s[c=d++]
1
> s[d]
2
> d
1
> s[c]
1
> d = 1
1
> s[--d]
1
> d
0
>


Invece abbiamo preferito per semplicità e non modificare troppo la struttura del codice
creare un nodo expression, che se si trova come condizione di un if while ecc
viene appesa questa condizione come expressione che ha al suo interno le varie operazioni di cui è composto


MENTRE SCRIVEVAMO LA GRAMMATICA
abbiamo incontrato la dimensione massimo della static initializer di 65535
1938 righe di codice!!!!!!


Empty statement restituisce vuoto
che viene propagato
nelle varie produzioni superiori si controlla di non aggiungere statement vuoti




