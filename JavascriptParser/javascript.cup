import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Iterator;

action code {:
    int curr_lineno() {
	return ((JavascriptLexer)parser.getScanner()).curr_lineno();
    }
    
    int curr_colno() {
	return ((JavascriptLexer)parser.getScanner()).curr_colno();
    }
    
:} 

parser code {:
    int omerrs = 0;

    public void syntax_error(Symbol cur_token){
        int lineno = action_obj.curr_lineno();
	System.err.println("Syntax error at "+ cur_token + " at line " + (lineno + 1));
	
    }

:}

terminal LBPAR, RBPAR, LPAR, RPAR, LSQPAR, RSQPAR, DOT, DOT3, COMMA, SEMI, COLON, ASSIGN, DPLUS, DMINUS, PLUS, MINUS, TILDE, NOT, STAR, DIV, DIVEQ, MOD, AND, OR, LANG, RANG, HAT, QUESTION, LEQ, GEQ, EQ, NEQ, TYPEEQ, TYPENEQ, TWOLANG, TWORANG, THREERANG, LOGAND, LOGOR, PLUSEQ, MINUSEQ, STAREQ, MODEQ, TWOLANGEQ, TWORANGEQ, THREERANGEQ, ANDEQ, OREQ, HATEQ, ARROW, TWOSTAREQ, DSTAR;
terminal DO, IN, IF, NEW, TRY, FOR, VAR, ELSE, THIS, CASE, VOID, WITH, BREAK, THROW, YIELD, CATCH, TARGET;
terminal CONST, CLASS, SUPER, WHILE, RETURN, EXPORT, DELETE, IMPORT, TYPEOF, SWITCH, EXTENDS, DEFAULT, LET, OF;
terminal FINALLY, DEBUGGER, FUNCTION, CONTINUE, INSTANCEOF, IDENTIFIERNAME, GET, SET, STATIC;
terminal DECIMALLITERAL, OCTALLITERAL, HEXLITERAL, BYNARYLITERAL, SIGNEDINTEGER;
terminal COMMENT, STRING_LITERAL, REGEXLITERAL, TEMPLATE, ERROR, ERROR_B, NULL, BOOLEANLITERAL;
nonterminal IdentifierReference, BindingIdentifier, LabelIdentifier, PrimaryExpression;
nonterminal Literal, ArrayLiteral, ObjectLiteral, FunctionExpression, ClassExpression, GeneratorExpression;
nonterminal TemplateLiteral, CPExpAAParList, Expression, NumericLiteral, Elision, ElementList, AssignmentExpression, SpreadElement, PropertyDefinitionList, PropertyDefinition,
PropertyName, LiteralPropertyName, ComputedPropertyName, CoverInizializedName, Initializer, MethodDefinition,
MemberExpression, SuperProperty, MetaProperty, Arguments, NewTarget, NewExpression,
CallExpression, SuperCall, ArgumentList, LeftHandSideExpression, UpdateExpression, UnaryExpression, ExponentiationExpression, MultiplicativeExpression, MultiplicativeOperator, AdditiveExpression, ShiftExpression, RelationalExpression,  EqualityExpression, BitwiseAndExpression, BitwiseXOrExpression,  BitwiseOrExpression, LogicalAndExpression, LogicalOrExpression, ConditionalExpression, YieldExpression, AssignmentOperator, AssignmentPattern, ObjectAssignmentPattern, ArrayAssignmentPattern, AssignmentPropertyList, AssignmentRestElement, AssignmentElementList, AssignmentProperty, AssignmentElisionElement, AssignmentElement, DestructuringAssignmentTarget, Statement, BlockStatement, VariableStatement, EmptyStatement, ExpressionStatement, IfStatement, BreakableStatement, ContinueStatement, BreakStatement, ReturnStatement, WithStatement, LabeledStatement, ThrowStatement, TryStatement, DebuggerStatement, Declaration, HoistableDeclaration, ClassDeclaration, LexicalDeclaration, 
FunctionDeclaration, GeneratorDeclaration, IterationStatement, SwitchStatement, Block, StatementList, StatementListItem,  LetOrConst, BindingList, LexicalBinding, BindingPattern, VariableDeclarationList, VariableDeclaration, ObjectBindingPattern, ArrayBindingPattern, BindingPropertyList, BindingRestElement, BindingElementList, BindingProperty, BindingElisionElement, Identifier,
BindingElement, SingleNameBinding, ForBinding, ForDeclaration, CaseBlock, CaseClauses, DefaultCase, CaseClause, LabeledItem, Catch, Finally, CatchParameter, FormalParameters, FunctionBody, StrictFormalParameters, FormalParameterList, FunctionRestParameter, FormalList, FormalParameter, FunctionStatementList, ArrowFunction, ArrowParameters,  ConciseBody, ArrowFormalParameters, GeneratorMethod, PropertySetParameterList, GeneratorBody, ClassTail, ClassHeritage, ClassBody, ClassElementList, ClassElement, Script, ScriptBody, YieldExpressionP;

start with Script;
    
Script
    ::= ScriptBody:sb
    {:
        JSTree.tree.getRoot().addChild((Node)sb);
    :}
    ;
    
ScriptBody
    ::= StatementList:sl
    {:
        RESULT = sl;
    :}
    ;
    

IdentifierReference
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;
    
BindingIdentifier
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;
    
Identifier
    ::= IDENTIFIERNAME:in
    {:
        System.out.println("line: "+curr_lineno()+" "+""+in);
        RESULT = new Identifier(in, curr_lineno());
    :}
    ;

LabelIdentifier
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;

PrimaryExpression
	::= THIS
    | IdentifierReference:ir
    {:
        RESULT = ir;
    :}
	| Literal:l
    {:
        RESULT = l;
    :}
	| ArrayLiteral
	| ObjectLiteral
	| FunctionExpression
	| ClassExpression
	| GeneratorExpression
	| REGEXLITERAL
	| TemplateLiteral
	| CPExpAAParList
	;

    /*CoverParenthesizedExpressionAndArrowParameterList*/
CPExpAAParList
	::= LPAR Expression RPAR
	| LPAR RPAR
	| LPAR DOT3 BindingIdentifier RPAR
    | LPAR DOT3 BindingPattern RPAR
	| LPAR Expression COMMA DOT3 BindingIdentifier RPAR
    | LPAR Expression COMMA DOT3 BindingPattern RPAR
	;
    
Literal
    ::= NULL
    | BOOLEANLITERAL
    | NumericLiteral:nl
    {:
        RESULT = new Literal(nl, curr_lineno(), new Node("int"));
    :}
    | STRING_LITERAL
    ;
    
NumericLiteral
    ::= DECIMALLITERAL:num
    {:
        System.out.println("line: "+curr_lineno()+" "+""+num);
        RESULT = num;
    :}
    | OCTALLITERAL:num
    {:
        System.out.println("line: "+curr_lineno()+" "+""+num);
    :}
    | HEXLITERAL:num
    {:
        System.out.println("line: "+curr_lineno()+" "+""+num);
    :}
    | BYNARYLITERAL:num
    {:
        System.out.println("line: "+curr_lineno()+" "+""+num);
    :}
    | SIGNEDINTEGER:num
    {:
        System.out.println("line: "+curr_lineno()+" "+""+num);
    :}
    ;
    
ArrayLiteral
    ::= LSQPAR Elision RSQPAR
    | LSQPAR RSQPAR
    | LSQPAR ElementList RSQPAR
    | LSQPAR ElementList COMMA Elision RSQPAR
    | LSQPAR ElementList COMMA RSQPAR
    ;
    
ElementList
    ::= Elision AssignmentExpression
    | AssignmentExpression
    | Elision SpreadElement
    | SpreadElement
    | ElementList COMMA Elision AssignmentExpression
    | ElementList COMMA AssignmentExpression
    | ElementList COMMA Elision SpreadElement
    | ElementList COMMA SpreadElement
    ;

Elision
    ::= COMMA
    | Elision COMMA
    ;
    
SpreadElement
    ::= DOT3 AssignmentExpression
    ;

ObjectLiteral
    ::= LBPAR RBPAR
    | LBPAR PropertyDefinitionList RBPAR
    | LBPAR PropertyDefinitionList COMMA RBPAR
    ;

PropertyDefinitionList
    ::= PropertyDefinition
    | PropertyDefinitionList COMMA PropertyDefinition
    ;

PropertyDefinition
    ::= IdentifierReference
    | CoverInizializedName
    | PropertyName COLON AssignmentExpression
    | MethodDefinition
    ;
    
PropertyName
    ::= LiteralPropertyName
    | ComputedPropertyName
    ;
    
LiteralPropertyName
    ::= IDENTIFIERNAME
    | STRING_LITERAL
    | NumericLiteral
    ;

ComputedPropertyName
    ::= LSQPAR AssignmentExpression RSQPAR
    ;

CoverInizializedName
    ::= IdentifierReference Initializer
    ;
    
Initializer
    ::= ASSIGN AssignmentExpression:ae
    {:
        RESULT = ae;
    :}
    ;

MemberExpression
    ::= PrimaryExpression:pe
    {:
        RESULT = pe;
    :}
    | MemberExpression LSQPAR Expression RSQPAR
    | MemberExpression DOT IDENTIFIERNAME
    | SuperProperty
    | MetaProperty
    | NEW MemberExpression Arguments
    ;

SuperProperty
    ::= SUPER LSQPAR Expression RSQPAR
    | SUPER DOT IDENTIFIERNAME
    ;

MetaProperty
    ::= NewTarget
    ;
    
NewTarget
    ::= NEW DOT TARGET
    ;

NewExpression
    ::= MemberExpression:me
    {:
        RESULT = me;
    :}
    | NEW NewExpression
    ;

CallExpression
    ::= MemberExpression Arguments
    | SuperCall
    | CallExpression Arguments
    | CallExpression LSQPAR Expression RSQPAR
    | CallExpression DOT IDENTIFIERNAME
    ;
    
SuperCall
    ::= SUPER Arguments
    ;

Arguments
    ::= LPAR RPAR
    | LPAR ArgumentList RPAR
    ;
    
ArgumentList
    ::= AssignmentExpression
    | DOT3 AssignmentExpression
    | ArgumentList COMMA AssignmentExpression
    | ArgumentList COMMA DOT3 AssignmentExpression
    ;
    
LeftHandSideExpression
    ::= NewExpression:ne
    {:
        RESULT = ne;
    :}
    | CallExpression
    ;

UpdateExpression
    ::= LeftHandSideExpression:lh
    {:
        RESULT = lh;
    :}
    | LeftHandSideExpression:lh DPLUS
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("PLUS", (Node)lh, (Node)me, curr_lineno());
        Assign as = new LateAssign(null, (Node)lh, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | LeftHandSideExpression:lh DMINUS
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("MINUS", (Node)lh, (Node)me, curr_lineno());
        Assign as = new LateAssign(null, (Node)lh, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | DPLUS UnaryExpression:ue
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("PLUS", (Node)ue, (Node)me, curr_lineno());
        Assign as = new Assign(null, (Node)ue, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | DMINUS UnaryExpression:ue
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("MINUS", (Node)ue, (Node)me, curr_lineno());
        Assign as = new Assign(null, (Node)ue, (Node)op, curr_lineno());
        RESULT = as;
    :}
    ;
    
UnaryExpression
    ::= UpdateExpression:ue
    {:
        RESULT = ue;
    :}
    | DELETE UnaryExpression
    | VOID UnaryExpression
    | TYPEOF UnaryExpression
    | PLUS UnaryExpression
    | MINUS UnaryExpression
    | TILDE UnaryExpression
    | NOT UnaryExpression
    ;
    
ExponentiationExpression
    ::= UnaryExpression:ue
    {:
        RESULT = ue;
    :}
    | UpdateExpression:ue DSTAR ExponentiationExpression:ee
    {:
        Operation op = new Operation("EXP", (Node)ue, (Node)ee, curr_lineno());
        RESULT = op;
    :}
    ;
    
MultiplicativeExpression
    ::= ExponentiationExpression:ee
    {:
        RESULT = ee;
    :}
    | MultiplicativeExpression:me MultiplicativeOperator:mo ExponentiationExpression:ee
    {:
        Operation op = new Operation((String)mo, (Node)me, (Node)ee, curr_lineno());
        RESULT = op;
    :}
    ;
    
MultiplicativeOperator 
    ::= STAR
    {:
        RESULT = "MULT";
    :}
    | DIV
    {:
        RESULT = "DIV";
    :}
    | MOD
    {:
        RESULT = "MOD";
    :}
    ;
    
AdditiveExpression
    ::= MultiplicativeExpression:me
    {:
        RESULT = me;
    :}
    | AdditiveExpression:ae PLUS MultiplicativeExpression:me
    {:
        Operation op = new Operation("PLUS", (Node)ae, (Node)me, curr_lineno());
        RESULT = op;
    :}
    | AdditiveExpression:ae MINUS MultiplicativeExpression:me
    {:
        Operation op = new Operation("MINUS", (Node)ae, (Node)me, curr_lineno());
        RESULT = op;
    :}
    ;
    
ShiftExpression
    ::= AdditiveExpression:ae
    {:
        RESULT = ae;
    :}
    | ShiftExpression TWOLANG AdditiveExpression
    | ShiftExpression TWORANG AdditiveExpression
    | ShiftExpression THREERANG AdditiveExpression
    ;
    
RelationalExpression
    ::= ShiftExpression:se
    {:
        RESULT = se;
    :}
    | RelationalExpression LANG ShiftExpression
    | RelationalExpression RANG ShiftExpression
    | RelationalExpression LEQ ShiftExpression
    | RelationalExpression GEQ ShiftExpression
    | RelationalExpression INSTANCEOF ShiftExpression
    | RelationalExpression IN ShiftExpression
    ;
    
EqualityExpression
    ::= RelationalExpression:re
    {:
        RESULT = re;
    :}
    | EqualityExpression EQ RelationalExpression
    | EqualityExpression NEQ RelationalExpression
    | EqualityExpression TYPEEQ RelationalExpression
    | EqualityExpression TYPENEQ RelationalExpression
    ;
    
BitwiseAndExpression
    ::= EqualityExpression:ee
    {:
        RESULT = ee;
    :}
    | BitwiseAndExpression AND EqualityExpression
    ;
    
    
BitwiseXOrExpression
    ::= BitwiseAndExpression:ba
    {:
        RESULT = ba;
    :}
    | BitwiseXOrExpression HAT BitwiseAndExpression
    ;
    
BitwiseOrExpression
    ::= BitwiseXOrExpression:bx
    {:
        RESULT = bx;
    :}
    | BitwiseOrExpression OR BitwiseXOrExpression
    ;

LogicalAndExpression
    ::= BitwiseOrExpression:bo
    {:
        RESULT = bo;
    :}
    | LogicalAndExpression LOGAND BitwiseOrExpression
    ;

LogicalOrExpression
    ::= LogicalAndExpression:la
    {:
        RESULT = la;
    :}
    | LogicalOrExpression LOGOR LogicalAndExpression
    ;
    
ConditionalExpression
    ::= LogicalOrExpression:lo
    {:
        RESULT = lo;
    :}
    | LogicalOrExpression QUESTION AssignmentExpression COLON AssignmentExpression
    ;
    
AssignmentExpression
    ::= ConditionalExpression:ce
    {:
        RESULT = ce;
    :}
    | YieldExpression
    | LeftHandSideExpression ASSIGN AssignmentExpression
    {:
        System.out.println("line: "+curr_lineno()+" AssignmentExpression -> LeftHandSideExpression ASSIGN AssignmentExpression");
    :}
    | LeftHandSideExpression:lh AssignmentOperator:ao AssignmentExpression:ae
    {:
        Operation op = new Operation((String)ao, (Node)lh, (Node)ae, curr_lineno());
        Assign as = new Assign(null, (Node)lh, op, curr_lineno());
        RESULT = as;
    :}
    | IdentifierReference:ir Initializer:i
    {:
        Node el = (Node)i;
        if(el instanceof LateAssign){
            Node child = (Node) el.getChilds().get(0);
            Assign a = new Assign(null, (Node)ir, child, curr_lineno());
            ArrayList<Node> list = new ArrayList<Node>();
            list.add(a);
            list.add(el);
            RESULT = list;
        }
        else{
            Assign a = new Assign(null, (Node)ir, el, curr_lineno());
            RESULT = a;
        }
    :}
    ;

/*    
AssignmentPattern
    ::= ObjectAssignmentPattern
    | ArrayAssignmentPattern
    ;
    
ObjectAssignmentPattern
    ::= LBPAR RBPAR
    | LBPAR AssignmentPropertyList RBPAR
    | LBPAR AssignmentPropertyList COMMA RBPAR
    ;
    
ArrayAssignmentPattern
    ::= LSQPAR Elision AssignmentRestElement RSQPAR
    | LSQPAR Elision RSQPAR
    | LSQPAR AssignmentRestElement RSQPAR
    | LSQPAR RSQPAR
    | LSQPAR AssignmentElementList RSQPAR
    | LSQPAR AssignmentElementList COMMA Elision AssignmentRestElement RSQPAR
    | LSQPAR AssignmentElementList COMMA Elision RSQPAR
    | LSQPAR AssignmentElementList COMMA AssignmentRestElement RSQPAR
    | LSQPAR AssignmentElementList COMMA RSQPAR
    ;

AssignmentPropertyList
    ::= AssignmentProperty
    | AssignmentPropertyList COMMA AssignmentProperty
    ;
    
AssignmentElementList
    ::= AssignmentElisionElement
    | AssignmentElementList COMMA AssignmentElisionElement
    ;
 
AssignmentElisionElement
    ::= Elision AssignmentElement
    | AssignmentElement
    ;

AssignmentProperty
    ::= IdentifierReference Initializer
    | IdentifierReference
    | PropertyName COLON AssignmentElement
    ;
    
AssignmentElement
    ::= DestructuringAssignmentTarget Initializer
    | DestructuringAssignmentTarget
    ;
    
AssignmentRestElement
    ::= DOT3 DestructuringAssignmentTarget
    ;
    
DestructuringAssignmentTarget
    ::= LeftHandSideExpression
    ;
*/
   
AssignmentOperator
    ::= STAREQ
    {:
        RESULT = "MULT";
    :}
    | DIVEQ
    {:
        RESULT = "DIV";
    :}
    | MODEQ
    {:
        RESULT = "MOD";
    :}
    | PLUSEQ
    {:
        RESULT = "PLUS";
    :}
    | MINUSEQ
    {:
        RESULT = "MINUS";
    :}
    | TWOLANGEQ
    {:
        RESULT = "LEFT_SHIFT";
    :}
    | TWORANGEQ
    {:
        RESULT = "RIGHT_SHIFT";
    :}
    | THREERANGEQ
    {:
        RESULT = "UNS_RIGHT_SHIFT";
    :}
    | ANDEQ
    {:
        RESULT = "AND";
    :}
    | OREQ
    {:
        RESULT = "OR";
    :}
    | HATEQ
    {:
        RESULT = "XOR";
    :}
    | TWOSTAREQ
    {:
        RESULT = "EXP";
    :}
    ;

Expression
    ::= AssignmentExpression:ae
    {:
        RESULT = ae;
    :}
    | Expression COMMA AssignmentExpression
    ;
    
Statement
    ::= BlockStatement:bs
    {:
        RESULT = bs;
    :}
    | VariableStatement
    | EmptyStatement
    | ExpressionStatement:es
    {:
        RESULT = es;
    :}
    | IfStatement:is
    {:
        RESULT = is;
    :}
    | BreakableStatement
    | ContinueStatement
    | BreakStatement
    | ReturnStatement
    | WithStatement
    | LabeledStatement
    | ThrowStatement
    | TryStatement
    | DebuggerStatement
    ;
    
Declaration
    ::= HoistableDeclaration
    | ClassDeclaration
    | LexicalDeclaration
    ;
    
HoistableDeclaration
    ::= FunctionDeclaration
    | GeneratorDeclaration
    ;
    
BreakableStatement
    ::= IterationStatement
    | SwitchStatement
    ;
    
BlockStatement
    ::= Block:b
    {:
        RESULT = b;
    :}
    ;
    
Block
    ::= LBPAR StatementList:sl RBPAR
    {:
        RESULT = sl;
    :}
    ;
    
StatementList
    ::= StatementListItem:sli
    {:
        StatementList list = new StatementList();
        if (sli instanceof ArrayList){
            sli = (ArrayList<Node>)sli;
            Iterator it = ((ArrayList) sli).iterator();
            while(it.hasNext()){
            	list.addChild(((Node)it.next()));
            }
        }
        else{
            list.addChild((Node)sli);
        }
        
        RESULT = list;
    :}
    | StatementList:sl StatementListItem:sli
    {:
        if (sli instanceof ArrayList){
            sli = (ArrayList<Node>)sli;
            Iterator it = ((ArrayList) sli).iterator();
            while(it.hasNext()){
            	((Node)sl).addChild(((Node)it.next()));
            }
        }
        else{
            ((Node)sl).addChild((Node)sli);
        }
        RESULT = sl;
    :}
    ;
    
StatementListItem
    ::= Statement:s
    {:
        RESULT = s;
    :}
    | Declaration
    ;

LexicalDeclaration
    ::= LetOrConst BindingList
    ;
    
LetOrConst
    ::= LET
    | CONST
    ;
    
BindingList
    ::= LexicalBinding
    | BindingList COMMA LexicalBinding
    ;
    
LexicalBinding
    ::= BindingIdentifier Initializer
    | BindingIdentifier
    | BindingPattern Initializer
    ;
    
VariableStatement
    ::= VAR VariableDeclarationList SEMI
     {:
        System.out.println("line: "+curr_lineno()+" "+"line: "+curr_lineno()+" "+"VariableStatement -> VAR VariableDeclarationList SEMI");
    :}
    ;
    
VariableDeclarationList
    ::= VariableDeclaration
    | VariableDeclarationList COMMA VariableDeclaration
    ;
    
VariableDeclaration
    ::= BindingIdentifier Initializer
    | BindingIdentifier
    | BindingPattern Initializer
    ;
    
BindingPattern
    ::= ObjectBindingPattern
    | ArrayBindingPattern
    ;

ObjectBindingPattern
    ::= LBPAR RBPAR
    | LBPAR BindingPropertyList RBPAR
    | LBPAR BindingPropertyList COMMA RBPAR
    ;
    
ArrayBindingPattern
    ::= LSQPAR Elision BindingRestElement RSQPAR
    | LSQPAR Elision RSQPAR
    | LSQPAR BindingRestElement RSQPAR
    | LSQPAR RSQPAR
    | LSQPAR BindingElementList RSQPAR
    | LSQPAR BindingElementList COMMA Elision BindingRestElement RSQPAR
    | LSQPAR BindingElementList COMMA Elision RSQPAR
    | LSQPAR BindingElementList COMMA BindingRestElement RSQPAR
    | LSQPAR BindingElementList COMMA RSQPAR
    ;
    
BindingPropertyList
    ::= BindingProperty
    | BindingPropertyList COMMA BindingProperty
    ;
    
BindingElementList
    ::= BindingElisionElement
    | BindingElementList COMMA BindingElisionElement
    ;

BindingElisionElement
    ::= Elision BindingElement
    | BindingElement
    ;
    
BindingProperty
    ::= SingleNameBinding
    | PropertyName COLON BindingElement
    ;
    
BindingElement
    ::= SingleNameBinding
    | BindingPattern Initializer
    | BindingPattern
    ;
    
SingleNameBinding
    ::= BindingIdentifier Initializer
    | BindingIdentifier
    ;
    
BindingRestElement
    ::= DOT3 BindingIdentifier
    | DOT3 BindingPattern
    ;
    
EmptyStatement
    ::= SEMI
    ;
    
ExpressionStatement
    ::= Expression:e SEMI
    {:
        RESULT = e;
    :}
    ;
    
IfStatement
    ::= IF LPAR Expression:e RPAR Statement:s1 ELSE Statement:s2
    {:
        IfNode ifn = new IfNode((Node)e, (Node)s1, (Node)s2, curr_lineno());
        RESULT = ifn;
    :}
    | IF LPAR Expression:e RPAR Statement:s
    {:
        IfNode ifn = new IfNode((Node)e, (Node)s, curr_lineno());
        RESULT = ifn;
    :}
    ;
    
IterationStatement
    ::= DO Statement WHILE LPAR Expression RPAR SEMI
    | WHILE LPAR Expression RPAR Statement
    | FOR LPAR Expression SEMI Expression SEMI Expression RPAR Statement
    | FOR LPAR Expression SEMI SEMI RPAR Statement
    | FOR LPAR SEMI Expression SEMI RPAR Statement
    | FOR LPAR SEMI SEMI Expression RPAR Statement
    | FOR LPAR Expression SEMI Expression SEMI RPAR Statement
    | FOR LPAR Expression SEMI SEMI Expression RPAR Statement
    | FOR LPAR SEMI Expression SEMI Expression RPAR Statement
    | FOR LPAR SEMI SEMI RPAR Statement
    | FOR LPAR VAR VariableDeclarationList SEMI Expression SEMI Expression RPAR Statement
    | FOR LPAR VAR VariableDeclarationList SEMI Expression SEMI RPAR Statement
    | FOR LPAR VAR VariableDeclarationList SEMI SEMI Expression RPAR Statement
    | FOR LPAR VAR VariableDeclarationList SEMI SEMI RPAR Statement
    | FOR LPAR LexicalDeclaration Expression SEMI Expression RPAR Statement
    | FOR LPAR LexicalDeclaration Expression SEMI RPAR Statement
    | FOR LPAR LexicalDeclaration SEMI Expression RPAR Statement
    | FOR LPAR LexicalDeclaration SEMI RPAR Statement
    | FOR LPAR LeftHandSideExpression IN Expression RPAR Statement
    | FOR LPAR VAR ForBinding IN Expression RPAR Statement
    | FOR LPAR ForDeclaration IN Expression RPAR Statement
    | FOR LPAR LeftHandSideExpression OF AssignmentExpression RPAR Statement
    | FOR LPAR VAR ForBinding OF AssignmentExpression RPAR Statement
    | FOR LPAR ForDeclaration OF AssignmentExpression RPAR Statement
    ;
    
ForDeclaration
    ::= LetOrConst ForBinding
    ;
    
ForBinding
    ::= BindingIdentifier
    | BindingPattern
    ;
    
ContinueStatement
    ::= CONTINUE SEMI
    | CONTINUE LabelIdentifier SEMI
    ;
    
BreakStatement
    ::= BREAK SEMI
    | BREAK LabelIdentifier SEMI
    ;
    
ReturnStatement
    ::= RETURN SEMI
    | RETURN Expression SEMI
    ;
    
WithStatement
    ::= WITH LPAR Expression RPAR Statement
    ;
    
SwitchStatement
    ::= SWITCH LPAR Expression RPAR CaseBlock
    ;
    
CaseBlock
    ::= LBPAR CaseClauses RBPAR
    | LBPAR RBPAR
    | LBPAR CaseClauses DefaultCase CaseClauses RBPAR
    | LBPAR CaseClauses DefaultCase RBPAR
    | LBPAR DefaultCase CaseClauses RBPAR
    | LBPAR DefaultCase RBPAR
    ;
    
CaseClauses
    ::= CaseClause
    | CaseClauses CaseClause
    ;
    
CaseClause
    ::= CASE Expression COLON StatementList
    | CASE Expression COLON
    ;
    
DefaultCase
    ::= DEFAULT COLON StatementList
    | DEFAULT COLON
    ;
    
LabeledStatement
    ::= LabelIdentifier COLON LabeledItem
    ;
   
LabeledItem
    ::= Statement
    | FunctionDeclaration
    ;
    
ThrowStatement
    ::= THROW Expression
    ;
    
TryStatement
    ::= TRY Block Catch
    | TRY Block Finally
    | TRY Block Catch Finally
    ;
    
Catch
    ::= CATCH LPAR CatchParameter RPAR Block
    ;
    
Finally
    ::= FINALLY Block
    ;
    
CatchParameter
    ::= BindingIdentifier
    | BindingPattern
    ;
    
DebuggerStatement
    ::= DEBUGGER
    ;
    
FunctionDeclaration
    ::= FUNCTION BindingIdentifier LPAR FormalParameters RPAR LBPAR FunctionBody RBPAR
    | FUNCTION LPAR FormalParameters RPAR LBPAR FunctionBody RBPAR
    ;
    
FunctionExpression
    ::= FUNCTION BindingIdentifier LPAR FormalParameters RPAR LBPAR FunctionBody RBPAR
    | FUNCTION LPAR FormalParameters RPAR LBPAR FunctionBody RBPAR
    ;
    
StrictFormalParameters
    ::= FormalParameters
    ;
    
FormalParameters
    ::= 
    | FormalParameterList
    ;
    
FormalParameterList
    ::= FunctionRestParameter
    | FormalList
    | FormalList COMMA FunctionRestParameter
    ;
    
FormalList
    ::= FormalParameter
    | FormalList COMMA FormalParameter
    ;
    
FunctionRestParameter
    ::= BindingRestElement
    ;
    
FormalParameter
    ::= BindingElement
    ;
    
FunctionBody
    ::= FunctionStatementList
    ;
    
FunctionStatementList
    ::= StatementList
    |
    ;

/*
ArrowFunction
    ::= ArrowParameters ARROW ConciseBody
    ;

 
ArrowParameters
    ::= BindingIdentifier
    | CPExpAAParList
    ;
 
ConciseBody
    ::= AssignmentExpression
    | LBPAR FunctionBody RBPAR
    ;
    
ArrowFormalParameters
    ::= LPAR StrictFormalParameters RPAR
    ;
*/

MethodDefinition
    ::= PropertyName LPAR StrictFormalParameters RPAR LBPAR FunctionBody RBPAR
    | GeneratorMethod
    | GET PropertyName LPAR RPAR LBPAR FunctionBody RBPAR
    | SET PropertyName LPAR PropertySetParameterList RPAR LBPAR FunctionBody RBPAR
    ;
    
PropertySetParameterList
    ::= FormalParameter
    ;
    
GeneratorMethod
    ::= STAR PropertyName LPAR StrictFormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorDeclaration
    ::= FUNCTION STAR BindingIdentifier LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    | FUNCTION STAR LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorExpression
    ::= FUNCTION STAR BindingIdentifier LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    | FUNCTION STAR LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorBody
    ::= FunctionBody
    ;

    
YieldExpression
    ::= YIELD YieldExpressionP 
    ;
    
YieldExpressionP
    ::= AssignmentExpression
    | STAR AssignmentExpression
    |
    ;
    
ClassDeclaration
    ::= CLASS BindingIdentifier ClassTail
    | CLASS ClassTail
    ;
    
ClassExpression
    ::= CLASS BindingIdentifier ClassTail
    | CLASS ClassTail
    ;
   
ClassTail
    ::= ClassHeritage LBPAR ClassBody RBPAR
    | ClassHeritage LBPAR RBPAR
    | LBPAR ClassBody RBPAR
    | LBPAR RBPAR
    ;
    
ClassHeritage
    ::= EXTENDS LeftHandSideExpression
    ;
    
ClassBody
    ::= ClassElementList
    ;
    
ClassElementList
    ::= ClassElement
    | ClassElementList ClassElement
    ;

    
ClassElement
    ::= MethodDefinition
    | STATIC MethodDefinition 
    | SEMI
    ;