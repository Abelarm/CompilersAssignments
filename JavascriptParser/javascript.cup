import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Iterator;

action code {:
    int curr_lineno() {
	return ((JavascriptLexer)parser.getScanner()).curr_lineno();
    }
    
    int curr_colno() {
	return ((JavascriptLexer)parser.getScanner()).curr_colno();
    }
    
:} 

parser code {:
    int omerrs = 0;

    public void syntax_error(Symbol cur_token){
        int lineno = action_obj.curr_lineno();
	System.err.println("Syntax error at "+ cur_token + " at line " + (lineno + 1));
	
    }

:}

terminal LBPAR, RBPAR, LPAR, RPAR, LSQPAR, RSQPAR, DOT, DOT3, COMMA, SEMI, COLON, ASSIGN, DPLUS, DMINUS, PLUS, MINUS, TILDE, NOT, STAR, DIV, DIVEQ, MOD, AND, OR, LT, GT, HAT, QUESTION, LEQ, GEQ, EQ, NEQ, TYPEEQ, TYPENEQ, TWOLANG, TWORANG, THREERANG, LOGAND, LOGOR, PLUSEQ, MINUSEQ, STAREQ, MODEQ, TWOLANGEQ, TWORANGEQ, THREERANGEQ, ANDEQ, OREQ, HATEQ, ARROW, TWOSTAREQ, DSTAR;
terminal DO, IN, IF, NEW, TRY, FOR, VAR, ELSE, THIS, CASE, VOID, WITH, BREAK, THROW, YIELD, CATCH, TARGET;
terminal CONST, CLASS, SUPER, WHILE, RETURN, EXPORT, DELETE, IMPORT, TYPEOF, SWITCH, EXTENDS, DEFAULT, LET, OF;
terminal FINALLY, DEBUGGER, FUNCTION, CONTINUE, INSTANCEOF, IDENTIFIERNAME, GET, SET, STATIC;
terminal DECIMALLITERAL, OCTALLITERAL, HEXLITERAL, BYNARYLITERAL, SIGNEDINTEGER;
terminal COMMENT, STRING_LITERAL, REGEXLITERAL, TEMPLATE, ERROR, ERROR_B, NULL, BOOLEANLITERAL;
nonterminal IdentifierReference, BindingIdentifier, LabelIdentifier, PrimaryExpression;
nonterminal Literal, ArrayLiteral, ObjectLiteral, FunctionExpression, ClassExpression, GeneratorExpression;
nonterminal TemplateLiteral, CPExpAAParList, Expression, NumericLiteral, Elision, ElementList, AssignmentExpression, SpreadElement, PropertyDefinitionList, PropertyDefinition,
PropertyName, LiteralPropertyName, ComputedPropertyName, CoverInizializedName, Initializer, MethodDefinition,
MemberExpression, SuperProperty, MetaProperty, Arguments, NewTarget, NewExpression,
CallExpression, SuperCall, ArgumentList, LeftHandSideExpression, UpdateExpression, UnaryExpression, ExponentiationExpression, MultiplicativeExpression, MultiplicativeOperator, AdditiveExpression, ShiftExpression, RelationalExpression,  EqualityExpression, BitwiseAndExpression, BitwiseXOrExpression,  BitwiseOrExpression, LogicalAndExpression, LogicalOrExpression, ConditionalExpression, YieldExpression, AssignmentOperator, AssignmentPattern, ObjectAssignmentPattern, ArrayAssignmentPattern, AssignmentPropertyList, AssignmentRestElement, AssignmentElementList, AssignmentProperty, AssignmentElisionElement, AssignmentElement, DestructuringAssignmentTarget, Statement, BlockStatement, VariableStatement, EmptyStatement, ExpressionStatement, IfStatement, BreakableStatement, ContinueStatement, BreakStatement, ReturnStatement, WithStatement, LabeledStatement, ThrowStatement, TryStatement, DebuggerStatement, Declaration, HoistableDeclaration, ClassDeclaration, LexicalDeclaration, 
FunctionDeclaration, GeneratorDeclaration, IterationStatement, SwitchStatement, Block, StatementList, StatementListItem,  LetOrConst, BindingList, LexicalBinding, BindingPattern, VariableDeclarationList, VariableDeclaration, ObjectBindingPattern, ArrayBindingPattern, BindingPropertyList, BindingRestElement, BindingElementList, BindingProperty, BindingElisionElement, Identifier,
BindingElement, SingleNameBinding, ForBinding, ForDeclaration, CaseBlock, CaseClauses, DefaultCase, CaseClause, LabeledItem, Catch, Finally, CatchParameter, FormalParameters, FunctionBody, StrictFormalParameters, FormalParameterList, FunctionRestParameter, FormalList, FormalParameter, FunctionStatementList, ArrowFunction, ArrowParameters,  ConciseBody, ArrowFormalParameters, GeneratorMethod, PropertySetParameterList, GeneratorBody, ClassTail, ClassHeritage, ClassBody, ClassElementList, ClassElement, Script, ScriptBody, YieldExpressionP;

start with Script;
    
Script
    ::= ScriptBody:sb
    {:
        JSTree.tree.getRoot().addChild((Node)sb);
    :}
    ;
    
ScriptBody
    ::= StatementList:sl
    {:
        RESULT = sl;
    :}
    ;
    

IdentifierReference
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;
    
BindingIdentifier
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;
    
Identifier
    ::= IDENTIFIERNAME:in
    {:
        System.out.println("line: "+curr_lineno()+" "+""+in);
        RESULT = new Identifier(in, curr_lineno());
    :}
    ;

LabelIdentifier
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;

PrimaryExpression
	::= THIS
    | IdentifierReference:ir
    {:
        RESULT = ir;
    :}
	| Literal:l
    {:
        RESULT = l;
    :}
	| ArrayLiteral:al
    {:
        RESULT = al;
    :}
	| ObjectLiteral
	| FunctionExpression
	| ClassExpression
	| GeneratorExpression
	| REGEXLITERAL
	| TemplateLiteral
	| CPExpAAParList
	;

    /*CoverParenthesizedExpressionAndArrowParameterList*/
CPExpAAParList
	::= LPAR Expression RPAR
	| LPAR RPAR
	| LPAR DOT3 BindingIdentifier RPAR
    | LPAR DOT3 BindingPattern RPAR
	| LPAR Expression COMMA DOT3 BindingIdentifier RPAR
    | LPAR Expression COMMA DOT3 BindingPattern RPAR
	;
    
Literal
    ::= NULL
    {:
        RESULT = new Literal("null", curr_lineno(), new Node("null"));
    :}
    | BOOLEANLITERAL:bl
    {:
        RESULT = new Literal(bl, curr_lineno(), new Node("boolean"));
    :}
    | NumericLiteral:nl
    {:
        RESULT = nl;
    :}
    | STRING_LITERAL:sl
    {:
        RESULT = new Literal(sl, curr_lineno(), new Node("String"));
    :}
    ;
    
NumericLiteral
    ::= DECIMALLITERAL:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Decimal int"));
    :}
    | OCTALLITERAL:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Octal int"));
    :}
    | HEXLITERAL:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Hex int"));
    :}
    | BYNARYLITERAL:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Binary int"));
    :}
    | SIGNEDINTEGER:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Signed int"));
    :}
    ;
    
ArrayLiteral
    ::= LSQPAR Elision RSQPAR
    | LSQPAR RSQPAR
    {:
        ArrayNode an = new ArrayNode(curr_lineno());
        RESULT = an;
    :}
    | LSQPAR ElementList:el RSQPAR
    {:
        ArrayNode an = new ArrayNode(curr_lineno());
        ArrayList<Node> elems = (ArrayList<Node>)el;
        Iterator it = elems.iterator();
            while(it.hasNext()){
            	an.addChild(((Node)it.next()));
            }
        RESULT = an;
    :}
    | LSQPAR ElementList:el COMMA Elision:e RSQPAR
    {:
        ArrayList<Node> elems = (ArrayList<Node>)el;
        elems.add(new Node(""));
        int rep = (int)e;
        while(rep!=0){
            elems.add(new Node(""));
            rep--;
        }
        ArrayNode an = new ArrayNode(curr_lineno());
        Iterator it = elems.iterator();
            while(it.hasNext()){
            	an.addChild(((Node)it.next()));
            }
        RESULT = an;
    :}
    | LSQPAR ElementList:el COMMA RSQPAR
    {:
        ArrayNode an = new ArrayNode(curr_lineno());
        ArrayList<Node> elems = (ArrayList<Node>)el;
        Iterator it = elems.iterator();
            while(it.hasNext()){
            	an.addChild(((Node)it.next()));
            }
        an.addChild(new Node(""));
        RESULT = an;
    :}
    ;
    
ElementList
    ::= Elision:e AssignmentExpression:ae
    {:
        ArrayList<Node> elems = new ArrayList<Node>();
        int rep = (int)e;
        while(rep!=0){
            elems.add(new Node(""));
            rep--;
        }
        elems.add((Node)ae);
        RESULT = elems;
    :}
    | AssignmentExpression:ae
    {:
        ArrayList<Node> elems = new ArrayList<Node>();
        elems.add((Node)ae);
        RESULT = elems;
    :}
    | Elision SpreadElement
    | SpreadElement
    | ElementList:el COMMA Elision:e AssignmentExpression:ae
    {:
        ArrayList<Node> elems = (ArrayList<Node>)el;
        int rep = (int)e;
        while(rep!=0){
            elems.add(new Node(""));
            rep--;
        }
        elems.add((Node)ae);
        RESULT = elems;
    :}
    | ElementList:el COMMA AssignmentExpression:ae
    {:
        ArrayList<Node> elems = (ArrayList<Node>)el;
        elems.add((Node)ae);
        RESULT = elems;
    :}
    | ElementList COMMA Elision SpreadElement
    | ElementList COMMA SpreadElement
    ;

Elision
    ::= COMMA
    {:
        RESULT = 1;
    :}
    | Elision:e COMMA{:
        int count = (int)e;
        RESULT = count+1;
    :}
    ;
    
SpreadElement
    ::= DOT3 AssignmentExpression
    ;

ObjectLiteral
    ::= LBPAR RBPAR
    | LBPAR PropertyDefinitionList RBPAR
    | LBPAR PropertyDefinitionList COMMA RBPAR
    ;

PropertyDefinitionList
    ::= PropertyDefinition
    | PropertyDefinitionList COMMA PropertyDefinition
    ;

PropertyDefinition
    ::= IdentifierReference
    | CoverInizializedName
    | PropertyName COLON AssignmentExpression
    | MethodDefinition
    ;
    
PropertyName
    ::= LiteralPropertyName
    | ComputedPropertyName
    ;
    
LiteralPropertyName
    ::= IDENTIFIERNAME
    | STRING_LITERAL
    | NumericLiteral
    ;

ComputedPropertyName
    ::= LSQPAR AssignmentExpression RSQPAR
    ;

CoverInizializedName
    ::= IdentifierReference Initializer
    ;
    
Initializer
    ::= ASSIGN AssignmentExpression:ae
    {:
        RESULT = ae;
    :}
    ;

MemberExpression
    ::= PrimaryExpression:pe
    {:
        RESULT = pe;
    :}
    | MemberExpression LSQPAR Expression RSQPAR
    | MemberExpression:me DOT IDENTIFIERNAME:fn
    {:
        Label obj = new Label("Callee", curr_lineno());
        obj.addChild((Node)me);
        Label name = new Label("Name", curr_lineno());
        name.addChild(new Identifier(""+fn, curr_lineno()));
        Function f = new Function(name, curr_lineno());
        Call c = new Call(obj, f, curr_lineno());
        RESULT = c;
    :}
    | SuperProperty
    | MetaProperty
    | NEW MemberExpression Arguments
    ;

SuperProperty
    ::= SUPER LSQPAR Expression RSQPAR
    | SUPER DOT IDENTIFIERNAME
    ;

MetaProperty
    ::= NewTarget
    ;
    
NewTarget
    ::= NEW DOT TARGET
    ;

NewExpression
    ::= MemberExpression:me
    {:
        RESULT = me;
    :}
    | NEW NewExpression
    ;

CallExpression
    ::= MemberExpression:m Arguments:arg
    {:
        Call m1;
        if(m instanceof Identifier){
            Label obj = new Label("Callee", curr_lineno());
            Label name = new Label("Name", curr_lineno());
            name.addChild((Node)m);
            Function f = new Function(name, curr_lineno());
            m1 = new Call(obj, f, curr_lineno());
        }
        else{
            m1 = (Call) m;
        }
        if(arg instanceof Arguments)
            m1.addArguments((Arguments)arg);
        RESULT = m1;
    :}
    | SuperCall
    | CallExpression:c Arguments:arg
    {:
        Call c1 = (Call) c;
        if(arg instanceof Arguments)
            c1.addArguments((Arguments)arg);
        RESULT = c1;
    :}
    | CallExpression LSQPAR Expression RSQPAR
    | CallExpression DOT IDENTIFIERNAME
    ;
    
SuperCall
    ::= SUPER Arguments
    ;

Arguments
    ::= LPAR RPAR
    | LPAR ArgumentList:al RPAR
    {:
        RESULT = al;
    :}
    ;
    
ArgumentList
    ::= AssignmentExpression:ae
    {:
        Arguments a = new Arguments(curr_lineno());
        a.addChild((Node)ae);
        RESULT = a;
    :}
    | DOT3 AssignmentExpression
    | ArgumentList:al COMMA AssignmentExpression:ae
    {:
        Arguments a = (Arguments) al;
        a.addChild((Node)ae);
        RESULT = a;
    :}
    | ArgumentList COMMA DOT3 AssignmentExpression
    ;
    
LeftHandSideExpression
    ::= NewExpression:ne
    {:
        RESULT = ne;
    :}
    | CallExpression:c
    {:
        RESULT = c;
    :}
    ;

UpdateExpression
    ::= LeftHandSideExpression:lh
    {:
        RESULT = lh;
    :}
    | LeftHandSideExpression:lh DPLUS
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("PLUS", (Node)lh, (Node)me, curr_lineno());
        Assign as = new LateAssign(null, (Node)lh, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | LeftHandSideExpression:lh DMINUS
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("MINUS", (Node)lh, (Node)me, curr_lineno());
        Assign as = new LateAssign(null, (Node)lh, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | DPLUS UnaryExpression:ue
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("PLUS", (Node)ue, (Node)me, curr_lineno());
        Assign as = new Assign(null, (Node)ue, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | DMINUS UnaryExpression:ue
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("MINUS", (Node)ue, (Node)me, curr_lineno());
        Assign as = new Assign(null, (Node)ue, (Node)op, curr_lineno());
        RESULT = as;
    :}
    ;
    
UnaryExpression
    ::= UpdateExpression:ue
    {:
        RESULT = ue;
    :}
    | DELETE UnaryExpression
    | VOID UnaryExpression
    | TYPEOF UnaryExpression
    | PLUS UnaryExpression
    | MINUS UnaryExpression
    | TILDE UnaryExpression
    | NOT UnaryExpression
    ;
    
ExponentiationExpression
    ::= UnaryExpression:ue
    {:
        RESULT = ue;
    :}
    | UpdateExpression:ue DSTAR ExponentiationExpression:ee
    {:
        Operation op = new Operation("EXP", (Node)ue, (Node)ee, curr_lineno());
        RESULT = op;
    :}
    ;
    
MultiplicativeExpression
    ::= ExponentiationExpression:ee
    {:
        RESULT = ee;
    :}
    | MultiplicativeExpression:me MultiplicativeOperator:mo ExponentiationExpression:ee
    {:
        Operation op = new Operation((String)mo, (Node)me, (Node)ee, curr_lineno());
        RESULT = op;
    :}
    ;
    
MultiplicativeOperator 
    ::= STAR
    {:
        RESULT = "MULT";
    :}
    | DIV
    {:
        RESULT = "DIV";
    :}
    | MOD
    {:
        RESULT = "MOD";
    :}
    ;
    
AdditiveExpression
    ::= MultiplicativeExpression:me
    {:
        RESULT = me;
    :}
    | AdditiveExpression:ae PLUS MultiplicativeExpression:me
    {:
        Operation op = new Operation("PLUS", (Node)ae, (Node)me, curr_lineno());
        RESULT = op;
    :}
    | AdditiveExpression:ae MINUS MultiplicativeExpression:me
    {:
        Operation op = new Operation("MINUS", (Node)ae, (Node)me, curr_lineno());
        RESULT = op;
    :}
    ;
    
ShiftExpression
    ::= AdditiveExpression:ae
    {:
        RESULT = ae;
    :}
    | ShiftExpression TWOLANG AdditiveExpression
    | ShiftExpression TWORANG AdditiveExpression
    | ShiftExpression THREERANG AdditiveExpression
    ;
    
RelationalExpression
    ::= ShiftExpression:se
    {:
        RESULT = se;
    :}
    | RelationalExpression:re LT ShiftExpression:se
    {:
        Operation b = new Operation("LESS THAN", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re GT ShiftExpression:se
    {:
        Operation b = new Operation("GREATER THAN", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re LEQ ShiftExpression:se
    {:
        Operation b = new Operation("LESS THAN OR EQUAL", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re GEQ ShiftExpression:se
    {:
        Operation b = new Operation("GREATER THAN OR EQUAL", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re INSTANCEOF ShiftExpression:se
    {:
        Operation b = new Operation("INSTANCEOF", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re IN ShiftExpression:se
    {:
        Operation b = new Operation("IN", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    ;
    
EqualityExpression
    ::= RelationalExpression:re
    {:
        RESULT = re;
    :}
    | EqualityExpression:ee EQ RelationalExpression:re
    {:
        Operation b = new Operation("EQUAL", (Node)ee, (Node)re, curr_lineno());
        RESULT = b;
    :}
    | EqualityExpression:ee NEQ RelationalExpression:re
    {:
        Operation b = new Operation("NOT EQUAL", (Node)ee, (Node)re, curr_lineno());
        RESULT = b;
    :}
    | EqualityExpression:ee TYPEEQ RelationalExpression:re
    {:
        Operation b = new Operation("TYPE EQUAL", (Node)ee, (Node)re, curr_lineno());
        RESULT = b;
    :}
    | EqualityExpression:ee TYPENEQ RelationalExpression:re
    {:
        Operation b = new Operation("TYPE NOT EQUAL", (Node)ee, (Node)re, curr_lineno());
        RESULT = b;
    :}
    ;
    
BitwiseAndExpression
    ::= EqualityExpression:ee
    {:
        RESULT = ee;
    :}
    | BitwiseAndExpression:be AND EqualityExpression:ee
    {:
        Operation b = new Operation("BITWISE AND", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;
    
    
BitwiseXOrExpression
    ::= BitwiseAndExpression:ba
    {:
        RESULT = ba;
    :}
    | BitwiseXOrExpression:be HAT BitwiseAndExpression:ee
    {:
        Operation b = new Operation("BITWISE XOR", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;
    
BitwiseOrExpression
    ::= BitwiseXOrExpression:bx
    {:
        RESULT = bx;
    :}
    | BitwiseOrExpression:be OR BitwiseXOrExpression:ee
    {:
        Operation b = new Operation("BITWISE OR", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;

LogicalAndExpression
    ::= BitwiseOrExpression:bo
    {:
        RESULT = bo;
    :}
    | LogicalAndExpression:be LOGAND BitwiseOrExpression:ee
    {:
        Operation b = new Operation("LOGICAL AND", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;

LogicalOrExpression
    ::= LogicalAndExpression:la
    {:
        RESULT = la;
    :}
    | LogicalOrExpression:be LOGOR LogicalAndExpression:ee
    {:
        Operation b = new Operation("LOGICAL OR", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;
    
ConditionalExpression
    ::= LogicalOrExpression:lo
    {:
        RESULT = lo;
    :}
    | LogicalOrExpression:lo QUESTION AssignmentExpression:ae1 COLON AssignmentExpression:ae2
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)lo);
        Label tl = new Label("Then Body", curr_lineno());
        tl.addChild((Node)ae1);
        Label el = new Label("Else Body", curr_lineno());
        el.addChild((Node)ae2);
        IfNode ifn = new IfNode(cl, tl, el, curr_lineno());
        RESULT = ifn;
    :}
    ;
    
AssignmentExpression
    ::= ConditionalExpression:ce
    {:
        RESULT = ce;
    :}
    | YieldExpression
    | LeftHandSideExpression ASSIGN AssignmentExpression
    {:
        System.out.println("line: "+curr_lineno()+" AssignmentExpression -> LeftHandSideExpression ASSIGN AssignmentExpression");
    :}
    | LeftHandSideExpression:lh AssignmentOperator:ao AssignmentExpression:ae
    {:
        Operation op = new Operation((String)ao, (Node)lh, (Node)ae, curr_lineno());
        Assign as = new Assign(null, (Node)lh, op, curr_lineno());
        RESULT = as;
    :}
    | IdentifierReference:ir Initializer:i
    {:
        Node el = (Node)i;
        if(el instanceof LateAssign){
            Node child = (Node) el.getChilds().get(0);
            Assign a = new Assign(null, (Node)ir, child, curr_lineno());
            ArrayList<Node> list = new ArrayList<Node>();
            list.add(a);
            list.add(el);
            RESULT = list;
        }
        else{
            Assign a = new Assign(null, (Node)ir, el, curr_lineno());
            RESULT = a;
        }
    :}
    ;

/*    
AssignmentPattern
    ::= ObjectAssignmentPattern
    | ArrayAssignmentPattern
    ;
    
ObjectAssignmentPattern
    ::= LBPAR RBPAR
    | LBPAR AssignmentPropertyList RBPAR
    | LBPAR AssignmentPropertyList COMMA RBPAR
    ;
    
ArrayAssignmentPattern
    ::= LSQPAR Elision AssignmentRestElement RSQPAR
    | LSQPAR Elision RSQPAR
    | LSQPAR AssignmentRestElement RSQPAR
    | LSQPAR RSQPAR
    | LSQPAR AssignmentElementList RSQPAR
    | LSQPAR AssignmentElementList COMMA Elision AssignmentRestElement RSQPAR
    | LSQPAR AssignmentElementList COMMA Elision RSQPAR
    | LSQPAR AssignmentElementList COMMA AssignmentRestElement RSQPAR
    | LSQPAR AssignmentElementList COMMA RSQPAR
    ;

AssignmentPropertyList
    ::= AssignmentProperty
    | AssignmentPropertyList COMMA AssignmentProperty
    ;
    
AssignmentElementList
    ::= AssignmentElisionElement
    | AssignmentElementList COMMA AssignmentElisionElement
    ;
 
AssignmentElisionElement
    ::= Elision AssignmentElement
    | AssignmentElement
    ;

AssignmentProperty
    ::= IdentifierReference Initializer
    | IdentifierReference
    | PropertyName COLON AssignmentElement
    ;
    
AssignmentElement
    ::= DestructuringAssignmentTarget Initializer
    | DestructuringAssignmentTarget
    ;
    
AssignmentRestElement
    ::= DOT3 DestructuringAssignmentTarget
    ;
    
DestructuringAssignmentTarget
    ::= LeftHandSideExpression
    ;
*/
   
AssignmentOperator
    ::= STAREQ
    {:
        RESULT = "MULT";
    :}
    | DIVEQ
    {:
        RESULT = "DIV";
    :}
    | MODEQ
    {:
        RESULT = "MOD";
    :}
    | PLUSEQ
    {:
        RESULT = "PLUS";
    :}
    | MINUSEQ
    {:
        RESULT = "MINUS";
    :}
    | TWOLANGEQ
    {:
        RESULT = "LEFT_SHIFT";
    :}
    | TWORANGEQ
    {:
        RESULT = "RIGHT_SHIFT";
    :}
    | THREERANGEQ
    {:
        RESULT = "UNS_RIGHT_SHIFT";
    :}
    | ANDEQ
    {:
        RESULT = "AND";
    :}
    | OREQ
    {:
        RESULT = "OR";
    :}
    | HATEQ
    {:
        RESULT = "XOR";
    :}
    | TWOSTAREQ
    {:
        RESULT = "EXP";
    :}
    ;

Expression
    ::= AssignmentExpression:ae
    {:
        RESULT = ae;
    :}
    | Expression COMMA AssignmentExpression
    ;
    
Statement
    ::= BlockStatement:bs
    {:
        RESULT = bs;
    :}
    | VariableStatement:vs
    {:
        RESULT = vs;
    :}
    | EmptyStatement
    | ExpressionStatement:es
    {:
        RESULT = es;
    :}
    | IfStatement:is
    {:
        RESULT = is;
    :}
    | BreakableStatement:bs
    {:
        RESULT = bs;
    :}
    | ContinueStatement
    {:
        Label c = new Label("CONTINUE",curr_lineno());
        RESULT = c;
    :}
    | BreakStatement
    {:
        Label b = new Label("BREAK",curr_lineno());
        RESULT = b;
    :}
    | ReturnStatement:r
    {:
        RESULT = r;
    :}
    | WithStatement
    | LabeledStatement
    | ThrowStatement
    | TryStatement
    | DebuggerStatement
    ;
    
Declaration
    ::= HoistableDeclaration
    | ClassDeclaration
    | LexicalDeclaration
    ;
    
HoistableDeclaration
    ::= FunctionDeclaration
    | GeneratorDeclaration
    ;
    
BreakableStatement
    ::= IterationStatement:is
    {:
        RESULT = is;
    :}
    | SwitchStatement:ss
    {:
        RESULT = ss;
    :}
    ;
    
BlockStatement
    ::= Block:b
    {:
        RESULT = b;
    :}
    ;
    
Block
    ::= LBPAR StatementList:sl RBPAR
    {:
        RESULT = sl;
    :}
    ;
    
StatementList
    ::= StatementListItem:sli
    {:
        StatementList list = new StatementList();
        if (sli instanceof ArrayList){
            sli = (ArrayList<Node>)sli;
            Iterator it = ((ArrayList) sli).iterator();
            while(it.hasNext()){
            	list.addChild(((Node)it.next()));
            }
        }
        else{
            list.addChild((Node)sli);
        }
        
        RESULT = list;
    :}
    | StatementList:sl StatementListItem:sli
    {:
        if (sli instanceof ArrayList){
            sli = (ArrayList<Node>)sli;
            Iterator it = ((ArrayList) sli).iterator();
            while(it.hasNext()){
            	((Node)sl).addChild(((Node)it.next()));
            }
        }
        else{
            ((Node)sl).addChild((Node)sli);
        }
        RESULT = sl;
    :}
    ;
    
StatementListItem
    ::= Statement:s
    {:
        RESULT = s;
    :}
    | Declaration
    ;

LexicalDeclaration
    ::= LetOrConst BindingList
    ;
    
LetOrConst
    ::= LET
    | CONST
    ;
    
BindingList
    ::= LexicalBinding
    | BindingList COMMA LexicalBinding
    ;
    
LexicalBinding
    ::= BindingIdentifier Initializer
    | BindingIdentifier
    | BindingPattern Initializer
    ;
    
VariableStatement
    ::= VAR VariableDeclarationList:vl SEMI
     {:
        RESULT = vl;
    :}
    ;
    
VariableDeclarationList
    ::= VariableDeclaration:vd
    {:
        DeclarationList list = new DeclarationList();
        list.addChild((Node)vd);
        RESULT = list;
    :}
    | VariableDeclarationList:vl COMMA VariableDeclaration:vd
    {:
        ((DeclarationList)vl).addChild((Node)vd);
        RESULT = vl;
    :}
    ;
    
VariableDeclaration
    ::= BindingIdentifier:bi Initializer:i
    {:
        Assign as = new Assign(null, (Node)bi, (Node)i, curr_lineno());
        RESULT = as;
    :}
    | BindingIdentifier:bi
    {:
        RESULT = bi;
    :}
    | BindingPattern Initializer
    ;
    
BindingPattern
    ::= ObjectBindingPattern
    | ArrayBindingPattern
    ;

ObjectBindingPattern
    ::= LBPAR RBPAR
    | LBPAR BindingPropertyList RBPAR
    | LBPAR BindingPropertyList COMMA RBPAR
    ;
    
ArrayBindingPattern
    ::= LSQPAR Elision BindingRestElement RSQPAR
    | LSQPAR Elision RSQPAR
    | LSQPAR BindingRestElement RSQPAR
    | LSQPAR RSQPAR
    | LSQPAR BindingElementList RSQPAR
    | LSQPAR BindingElementList COMMA Elision BindingRestElement RSQPAR
    | LSQPAR BindingElementList COMMA Elision RSQPAR
    | LSQPAR BindingElementList COMMA BindingRestElement RSQPAR
    | LSQPAR BindingElementList COMMA RSQPAR
    ;
    
BindingPropertyList
    ::= BindingProperty
    | BindingPropertyList COMMA BindingProperty
    ;
    
BindingElementList
    ::= BindingElisionElement
    | BindingElementList COMMA BindingElisionElement
    ;

BindingElisionElement
    ::= Elision BindingElement
    | BindingElement
    ;
    
BindingProperty
    ::= SingleNameBinding
    | PropertyName COLON BindingElement
    ;
    
BindingElement
    ::= SingleNameBinding
    | BindingPattern Initializer
    | BindingPattern
    ;
    
SingleNameBinding
    ::= BindingIdentifier Initializer
    | BindingIdentifier
    ;
    
BindingRestElement
    ::= DOT3 BindingIdentifier
    | DOT3 BindingPattern
    ;
    
EmptyStatement
    ::= SEMI
    ;
    
ExpressionStatement
    ::= Expression:e SEMI
    {:
        RESULT = e;
    :}
    ;
    
IfStatement
    ::= IF LPAR Expression:e RPAR Statement:s1 ELSE Statement:s2
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e);
        Label tl = new Label("Then Body", curr_lineno());
        tl.addChild((Node)s1);
        Label el = new Label("Else Body", curr_lineno());
        el.addChild((Node)s2);
        IfNode ifn = new IfNode(cl, tl, el, curr_lineno());
        RESULT = ifn;
    :}
    | IF LPAR Expression:e RPAR Statement:s
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e);
        Label tl = new Label("Then Body", curr_lineno());
        tl.addChild((Node)s);
        IfNode ifn = new IfNode(cl, tl, curr_lineno());
        RESULT = ifn;
    :}
    ;
    
IterationStatement
    ::= DO Statement:s WHILE LPAR Expression:e RPAR SEMI
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        WhileOp w = new WhileOp("DO WHILE",bl, cl, curr_lineno());
        RESULT = w;
    :}
    | WHILE LPAR Expression:e RPAR Statement:s
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        WhileOp w = new WhileOp("WHILE",cl, bl, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR Expression:e1 SEMI Expression:e2 SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR Expression:e1 SEMI SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR SEMI Expression:e2 SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR SEMI SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR Expression:e1 SEMI Expression:e2 SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR Expression:e1 SEMI SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR SEMI Expression:e2 SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR SEMI SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR VariableDeclarationList:e1 SEMI Expression:e2 SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR VariableDeclarationList:e1 SEMI Expression:e2 SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR VariableDeclarationList:e1 SEMI SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR VariableDeclarationList:e1 SEMI SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR LexicalDeclaration Expression SEMI Expression RPAR Statement
    | FOR LPAR LexicalDeclaration Expression SEMI RPAR Statement
    | FOR LPAR LexicalDeclaration SEMI Expression RPAR Statement
    | FOR LPAR LexicalDeclaration SEMI RPAR Statement
    | FOR LPAR LeftHandSideExpression:lh IN Expression:e RPAR Statement:s
    {:
        Operation b = new Operation("IN", (Node)lh, (Node)e, curr_lineno());
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild(b);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR ForBinding IN Expression RPAR Statement
    | FOR LPAR ForDeclaration IN Expression RPAR Statement
    | FOR LPAR LeftHandSideExpression OF AssignmentExpression RPAR Statement
    | FOR LPAR VAR ForBinding OF AssignmentExpression RPAR Statement
    | FOR LPAR ForDeclaration OF AssignmentExpression RPAR Statement
    ;
    
ForDeclaration
    ::= LetOrConst ForBinding
    ;
    
ForBinding
    ::= BindingIdentifier
    | BindingPattern
    ;
    
ContinueStatement
    ::= CONTINUE SEMI
    | CONTINUE LabelIdentifier SEMI
    ;
    
BreakStatement
    ::= BREAK SEMI
    | BREAK LabelIdentifier SEMI
    ;
    
ReturnStatement
    ::= RETURN SEMI
    {:
        Return r = new Return(curr_lineno());
        RESULT = r;
    :}
    | RETURN Expression:e SEMI
    {:
         Return r = new Return((Node)e,curr_lineno());
        RESULT = r;
    :}
    ;
    
WithStatement
    ::= WITH LPAR Expression RPAR Statement
    ;
    
SwitchStatement
    ::= SWITCH LPAR Expression:e RPAR CaseBlock:cb
    {:
        Label l = new Label("Expression", curr_lineno());
        l.addChild((Node)e);
        Switch sw = new Switch(l, curr_lineno());
        if (cb instanceof ArrayList){
            cb = (ArrayList<Node>)cb;
            Iterator it = ((ArrayList) cb).iterator();
            while(it.hasNext()){
            	sw.addChild(((Node)it.next()));
            }
        }
        else{
            if(cb != null)
                sw.addChild((Node)cb);
        }
        RESULT = sw;
    :}
    ;
    
CaseBlock
    ::= LBPAR CaseClauses:cc RBPAR
    {:
        RESULT = cc;
    :}
    | LBPAR RBPAR
    | LBPAR CaseClauses:cc DefaultCase:d CaseClauses:cc2 RBPAR
    {:
        ((ArrayList<Node>)cc).add((Node)d);
        ((ArrayList<Node>)cc).addAll((ArrayList<Node>)cc2);
        RESULT = cc;
    :}
    | LBPAR CaseClauses:cc DefaultCase:d RBPAR
    {:
        ((ArrayList<Node>)cc).add((Node)d);
        RESULT = cc;
    :}
    | LBPAR DefaultCase:d CaseClauses:cc RBPAR
    {:
        ((ArrayList<Node>)cc).add((Node)d);
        RESULT = cc;
    :}
    | LBPAR DefaultCase:d RBPAR
    {:
        RESULT = d;
    :}
    ;
    
CaseClauses
    ::= CaseClause:cc
    {:
        ArrayList<Node> list = new ArrayList<Node>();
        list.add((Node)cc);
        RESULT = list;
    :}
    | CaseClauses:cl CaseClause:cc
    {:
        ((ArrayList<Node>)cl).add((Node)cc);
        RESULT = cl;
    :}
    ;
    
CaseClause
    ::= CASE Expression:e COLON StatementList:sl
    {:
        RESULT = new Clause("CASE",  (Node)e, (Node)sl, curr_lineno());
    :}
    | CASE Expression:e COLON
    {:
        RESULT = new Clause("CASE", (Node)e, curr_lineno());
    :}
    ;
    
DefaultCase
    ::= DEFAULT COLON StatementList:sl
    {:
        RESULT = new Clause("DEFAULT", (Node)sl, curr_lineno());
    :}
    | DEFAULT COLON
    {:
        RESULT = new Clause("DEFAULT", curr_lineno());
    :}
    ;
    
LabeledStatement
    ::= LabelIdentifier COLON LabeledItem
    ;
   
LabeledItem
    ::= Statement
    | FunctionDeclaration
    ;
    
ThrowStatement
    ::= THROW Expression
    ;
    
TryStatement
    ::= TRY Block Catch
    | TRY Block Finally
    | TRY Block Catch Finally
    ;
    
Catch
    ::= CATCH LPAR CatchParameter RPAR Block
    ;
    
Finally
    ::= FINALLY Block
    ;
    
CatchParameter
    ::= BindingIdentifier
    | BindingPattern
    ;
    
DebuggerStatement
    ::= DEBUGGER
    ;
    
FunctionDeclaration
    ::= FUNCTION BindingIdentifier LPAR FormalParameters RPAR LBPAR FunctionBody RBPAR
    | FUNCTION LPAR FormalParameters RPAR LBPAR FunctionBody RBPAR
    ;
    
FunctionExpression
    ::= FUNCTION BindingIdentifier LPAR FormalParameters RPAR LBPAR FunctionBody RBPAR
    | FUNCTION LPAR FormalParameters RPAR LBPAR FunctionBody RBPAR
    ;
    
StrictFormalParameters
    ::= FormalParameters
    ;
    
FormalParameters
    ::= 
    | FormalParameterList
    ;
    
FormalParameterList
    ::= FunctionRestParameter
    | FormalList
    | FormalList COMMA FunctionRestParameter
    ;
    
FormalList
    ::= FormalParameter
    | FormalList COMMA FormalParameter
    ;
    
FunctionRestParameter
    ::= BindingRestElement
    ;
    
FormalParameter
    ::= BindingElement
    ;
    
FunctionBody
    ::= FunctionStatementList
    ;
    
FunctionStatementList
    ::= StatementList
    |
    ;

/*
ArrowFunction
    ::= ArrowParameters ARROW ConciseBody
    ;

 
ArrowParameters
    ::= BindingIdentifier
    | CPExpAAParList
    ;
 
ConciseBody
    ::= AssignmentExpression
    | LBPAR FunctionBody RBPAR
    ;
    
ArrowFormalParameters
    ::= LPAR StrictFormalParameters RPAR
    ;
*/

MethodDefinition
    ::= PropertyName LPAR StrictFormalParameters RPAR LBPAR FunctionBody RBPAR
    | GeneratorMethod
    | GET PropertyName LPAR RPAR LBPAR FunctionBody RBPAR
    | SET PropertyName LPAR PropertySetParameterList RPAR LBPAR FunctionBody RBPAR
    ;
    
PropertySetParameterList
    ::= FormalParameter
    ;
    
GeneratorMethod
    ::= STAR PropertyName LPAR StrictFormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorDeclaration
    ::= FUNCTION STAR BindingIdentifier LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    | FUNCTION STAR LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorExpression
    ::= FUNCTION STAR BindingIdentifier LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    | FUNCTION STAR LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorBody
    ::= FunctionBody
    ;

    
YieldExpression
    ::= YIELD YieldExpressionP 
    ;
    
YieldExpressionP
    ::= AssignmentExpression
    | STAR AssignmentExpression
    |
    ;
    
ClassDeclaration
    ::= CLASS BindingIdentifier ClassTail
    | CLASS ClassTail
    ;
    
ClassExpression
    ::= CLASS BindingIdentifier ClassTail
    | CLASS ClassTail
    ;
   
ClassTail
    ::= ClassHeritage LBPAR ClassBody RBPAR
    | ClassHeritage LBPAR RBPAR
    | LBPAR ClassBody RBPAR
    | LBPAR RBPAR
    ;
    
ClassHeritage
    ::= EXTENDS LeftHandSideExpression
    ;
    
ClassBody
    ::= ClassElementList
    ;
    
ClassElementList
    ::= ClassElement
    | ClassElementList ClassElement
    ;

    
ClassElement
    ::= MethodDefinition
    | STATIC MethodDefinition 
    | SEMI
    ;