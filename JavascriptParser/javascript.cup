import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Iterator;
import java.lang.*;
import java.util.List;

action code {:
    int curr_lineno() {
	return ((JavascriptLexer)parser.getScanner()).curr_lineno();
    }
    
    int curr_colno() {
	return ((JavascriptLexer)parser.getScanner()).curr_colno();
    }
    
:} 

parser code {:
    int omerrs = 0;
    
    TokenUtils tokenMap = new TokenUtils();
    
    public void syntax_error(Symbol cur_token){
        report_error("Syntax error: ", cur_token);
    }
    
    public void report_error(String message, Object info){
        System.err.print(message+": ");
        Symbol curr = (Symbol)info;
        String name = symbl_name_from_id(curr.sym);
        if(name.equals("ERROR")|| name.equals("ERROR_B")){
            System.err.println(curr.value);
        }
        else{
            System.err.println("on line "+(action_obj.curr_lineno()+1));
            List<Integer> ids = expected_token_ids();
            System.err.print("Expected token: ");
            for (Integer expected : ids){
                System.err.print("\"");
                String token = TokenUtils.getSymbol(symbl_name_from_id(expected));
                if(token != ""){
                    System.err.print(token);
                }
                System.err.print("\", ");
            }
            System.err.println("");
        }
    }
    
    public void report_fatal_error(String message, Object info){
        done_parsing();
    }

:}

terminal LBPAR, RBPAR, LPAR, RPAR, LSQPAR, RSQPAR, DOT, DOT3, COMMA, SEMI, COLON, ASSIGN, DPLUS, DMINUS, PLUS, MINUS, TILDE, NOT, STAR, DIV, DIVEQ, MOD, AND, OR, LT, GT, HAT, QUESTION, LEQ, GEQ, EQ, NEQ, TYPEEQ, TYPENEQ, TWOLANG, TWORANG, THREERANG, LOGAND, LOGOR, PLUSEQ, MINUSEQ, STAREQ, MODEQ, TWOLANGEQ, TWORANGEQ, THREERANGEQ, ANDEQ, OREQ, HATEQ, ARROW, TWOSTAREQ, DSTAR;
terminal DO, IN, IF, NEW, TRY, FOR, VAR, ELSE, THIS, CASE, VOID, WITH, BREAK, THROW, YIELD, CATCH, TARGET;
terminal CONST, CLASS, SUPER, WHILE, RETURN, EXPORT, DELETE, IMPORT, TYPEOF, SWITCH, EXTENDS, DEFAULT, LET, OF;
terminal FINALLY, DEBUGGER, FUNCTION, CONTINUE, INSTANCEOF, IDENTIFIERNAME, GET, SET, STATIC;
terminal DECIMALLITERAL, OCTALLITERAL, HEXLITERAL, BYNARYLITERAL, SIGNEDINTEGER;
terminal COMMENT, STRING_LITERAL, REGEXLITERAL, TEMPLATE, ERROR, ERROR_B, NULL, BOOLEANLITERAL;
nonterminal IdentifierReference, BindingIdentifier, LabelIdentifier, PrimaryExpression;
nonterminal Literal, ArrayLiteral, ObjectLiteral, FunctionExpression, ClassExpression, GeneratorExpression;
nonterminal TemplateLiteral, CPExpAAParList, Expression, NumericLiteral, Elision, ElementList, AssignmentExpression, SpreadElement, PropertyDefinitionList, PropertyDefinition,
PropertyName, LiteralPropertyName, ComputedPropertyName, CoverInizializedName, Initializer, MethodDefinition,
MemberExpression, SuperProperty, MetaProperty, Arguments, NewTarget, NewExpression,
CallExpression, SuperCall, ArgumentList, LeftHandSideExpression, UpdateExpression, UnaryExpression, ExponentiationExpression, MultiplicativeExpression, MultiplicativeOperator, AdditiveExpression, ShiftExpression, RelationalExpression,  EqualityExpression, BitwiseAndExpression, BitwiseXOrExpression,  BitwiseOrExpression, LogicalAndExpression, LogicalOrExpression, ConditionalExpression, YieldExpression, AssignmentOperator, Statement, BlockStatement, VariableStatement, EmptyStatement, ExpressionStatement, IfStatement, BreakableStatement, ContinueStatement, BreakStatement, ReturnStatement, WithStatement, LabelledStatement, ThrowStatement, TryStatement, DebuggerStatement, Declaration, HoistableDeclaration, ClassDeclaration, LexicalDeclaration, 
FunctionDeclaration, GeneratorDeclaration, IterationStatement, SwitchStatement, Block, StatementList, StatementListItem,  LetOrConst, BindingList, LexicalBinding, BindingPattern, VariableDeclarationList, VariableDeclaration, ObjectBindingPattern, ArrayBindingPattern, BindingPropertyList, BindingRestElement, BindingElementList, BindingProperty, BindingElisionElement, Identifier,
BindingElement, SingleNameBinding, ForBinding, ForDeclaration, CaseBlock, CaseClauses, DefaultCase, CaseClause, LabelledItem, Catch, Finally, CatchParameter, FormalParameters, FunctionBody, StrictFormalParameters, FormalParameterList, FunctionRestParameter, FormalList, FormalParameter, FunctionStatementList,   GeneratorMethod, PropertySetParameterList, GeneratorBody, Script, ScriptBody, YieldExpressionP;

start with Script;
    
Script
    ::= ScriptBody:sb
    {:
        JSTree.tree.getRoot().addChild((Node)sb);
    :}
    ;
    
ScriptBody
    ::= StatementList:sl
    {:
        RESULT = sl;
    :}
    ;
    

IdentifierReference
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;
    
BindingIdentifier
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;
    
Identifier
    ::= IDENTIFIERNAME:in
    {:
        RESULT = new Identifier(in, curr_lineno());
    :}
    ;

LabelIdentifier
	::= Identifier:id
    {:
        RESULT = id;
    :}
	;

PrimaryExpression
	::= THIS
    | IdentifierReference:ir
    {:
        RESULT = ir;
    :}
	| Literal:l
    {:
        RESULT = l;
    :}
	| ArrayLiteral:al
    {:
        RESULT = al;
    :}
	| ObjectLiteral
	| FunctionExpression
	| ClassExpression
	| GeneratorExpression
	| REGEXLITERAL:rl
    {:
        RESULT = new Literal(rl, curr_lineno(), new Node("regex"));
    :}
	| TemplateLiteral
	| CPExpAAParList:ce
    {:
        RESULT = ce;
    :}
	;

    /*CoverParenthesizedExpressionAndArrowParameterList*/
CPExpAAParList
	::= LPAR Expression:e RPAR
    {:
        RESULT = e;
    :}
	| LPAR RPAR
	| LPAR DOT3 BindingIdentifier RPAR
    | LPAR DOT3 BindingPattern RPAR
	| LPAR Expression COMMA DOT3 BindingIdentifier RPAR
    | LPAR Expression COMMA DOT3 BindingPattern RPAR
	;
    
Literal
    ::= NULL
    {:
        RESULT = new Literal("null", curr_lineno(), new Node("null"));
    :}
    | BOOLEANLITERAL:bl
    {:
        RESULT = new Literal(bl, curr_lineno(), new Node("boolean"));
    :}
    | NumericLiteral:nl
    {:
        RESULT = nl;
    :}
    | STRING_LITERAL:sl
    {:
        RESULT = new Literal(sl, curr_lineno(), new Node("String"));
    :}
    ;
    
NumericLiteral
    ::= DECIMALLITERAL:num
    {:
        if(((String)num).contains(".")){
            RESULT = new Literal(num, curr_lineno(), new Node("Decimal float"));
        }
        else{
            RESULT = new Literal(num, curr_lineno(), new Node("Decimal int"));
        }
    :}
    | OCTALLITERAL:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Octal int"));
    :}
    | HEXLITERAL:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Hex int"));
    :}
    | BYNARYLITERAL:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Binary int"));
    :}
    | SIGNEDINTEGER:num
    {:
        RESULT = new Literal(num, curr_lineno(), new Node("Signed int"));
    :}
    ;
    
ArrayLiteral
    ::= LSQPAR Elision RSQPAR
    | LSQPAR RSQPAR
    {:
        ArrayNode an = new ArrayNode(curr_lineno());
        RESULT = an;
    :}
    | LSQPAR ElementList:el RSQPAR
    {:
        ArrayNode an = new ArrayNode(curr_lineno());
        ArrayList<Node> elems = (ArrayList<Node>)el;
        Iterator it = elems.iterator();
            while(it.hasNext()){
            	an.addChild(((Node)it.next()));
            }
        RESULT = an;
    :}
    | LSQPAR ElementList:el COMMA Elision:e RSQPAR
    {:
        ArrayList<Node> elems = (ArrayList<Node>)el;
        elems.add(new Node(""));
        int rep = (int)e;
        while(rep!=0){
            elems.add(new Node(""));
            rep--;
        }
        ArrayNode an = new ArrayNode(curr_lineno());
        Iterator it = elems.iterator();
            while(it.hasNext()){
            	an.addChild(((Node)it.next()));
            }
        RESULT = an;
    :}
    | LSQPAR ElementList:el COMMA RSQPAR
    {:
        ArrayNode an = new ArrayNode(curr_lineno());
        ArrayList<Node> elems = (ArrayList<Node>)el;
        Iterator it = elems.iterator();
            while(it.hasNext()){
            	an.addChild(((Node)it.next()));
            }
        an.addChild(new Node(""));
        RESULT = an;
    :}
    ;
    
ElementList
    ::= Elision:e AssignmentExpression:ae
    {:
        ArrayList<Node> elems = new ArrayList<Node>();
        int rep = (int)e;
        while(rep!=0){
            elems.add(new Node(""));
            rep--;
        }
        elems.add((Node)ae);
        RESULT = elems;
    :}
    | AssignmentExpression:ae
    {:
        ArrayList<Node> elems = new ArrayList<Node>();
        elems.add((Node)ae);
        RESULT = elems;
    :}
    | Elision SpreadElement
    | SpreadElement
    | ElementList:el COMMA Elision:e AssignmentExpression:ae
    {:
        ArrayList<Node> elems = (ArrayList<Node>)el;
        int rep = (int)e;
        while(rep!=0){
            elems.add(new Node(""));
            rep--;
        }
        elems.add((Node)ae);
        RESULT = elems;
    :}
    | ElementList:el COMMA AssignmentExpression:ae
    {:
        ArrayList<Node> elems = (ArrayList<Node>)el;
        elems.add((Node)ae);
        RESULT = elems;
    :}
    | ElementList COMMA Elision SpreadElement
    | ElementList COMMA SpreadElement
    ;

Elision
    ::= COMMA
    {:
        RESULT = 1;
    :}
    | Elision:e COMMA{:
        int count = (int)e;
        RESULT = count+1;
    :}
    ;
    
SpreadElement
    ::= DOT3 AssignmentExpression
    ;

ObjectLiteral
    ::= LBPAR RBPAR
    | LBPAR PropertyDefinitionList RBPAR
    | LBPAR PropertyDefinitionList COMMA RBPAR
    ;

PropertyDefinitionList
    ::= PropertyDefinition
    | PropertyDefinitionList COMMA PropertyDefinition
    ;

PropertyDefinition
    ::= IdentifierReference
    | CoverInizializedName
    | PropertyName COLON AssignmentExpression
    | MethodDefinition
    ;
    
PropertyName
    ::= LiteralPropertyName
    | ComputedPropertyName
    ;
    
LiteralPropertyName
    ::= IDENTIFIERNAME
    | STRING_LITERAL
    | NumericLiteral
    ;

ComputedPropertyName
    ::= LSQPAR AssignmentExpression RSQPAR
    ;

CoverInizializedName
    ::= IdentifierReference Initializer
    ;
    
Initializer
    ::= ASSIGN AssignmentExpression:ae
    {:
        RESULT = ae;
    :}
    ;

MemberExpression
    ::= PrimaryExpression:pe
    {:
        RESULT = pe;
    :}
    | MemberExpression:me LSQPAR Expression:e RSQPAR
    {:
        Label source = new Label("Source", curr_lineno());
        source.addChild((Node)me);
        Label access = new Label("Property", curr_lineno());
        access.addChild((Node)e);
        ItemAccess ia = new ItemAccess(source, access, curr_lineno());
        RESULT = ia;
    :}
    | MemberExpression:me DOT IDENTIFIERNAME:fn
    {:
        Label source = new Label("Source", curr_lineno());
        source.addChild((Node)me);
        Label access = new Label("Property", curr_lineno());
        Identifier id = new Identifier(""+fn, curr_lineno());
        access.addChild((Node)id);
        ItemAccess ia = new ItemAccess(source, access, curr_lineno());
        RESULT = ia;
    :}
    | SuperProperty
    | MetaProperty
    | NEW MemberExpression:me Arguments:a
    {:
        Label obj = new Label("Object", curr_lineno());
        obj.addChild((Node)me);
        Label arg = new Label("Arguments", curr_lineno());
        arg.addChild((Node)a);
        Constructor c = new Constructor(obj, arg, curr_lineno());
        RESULT = c;
    :}
    ;

SuperProperty
    ::= SUPER LSQPAR Expression RSQPAR
    | SUPER DOT IDENTIFIERNAME
    ;

MetaProperty
    ::= NewTarget
    ;
    
NewTarget
    ::= NEW DOT TARGET
    ;

NewExpression
    ::= MemberExpression:me
    {:
        RESULT = me;
    :}
    | NEW NewExpression
    ;

CallExpression
    ::= MemberExpression:m Arguments:arg
    {:
        Call m1;
        if(m instanceof Identifier){
            Label obj = new Label("Callee", curr_lineno());
            Label name = new Label("Name", curr_lineno());
            name.addChild((Node)m);
            Function f = new Function(name, curr_lineno());
            m1 = new Call(obj, f, curr_lineno());
        }
        else{
            if(m instanceof ItemAccess){
                ItemAccess acc = (ItemAccess) m;
                Label obj = new Label("Callee", curr_lineno());
                obj.addChild((Node)((Node)acc.getChilds().get(0)).getChilds().get(0));
                Label name = new Label("Name", curr_lineno());
                name.addChild((Node)((Node)acc.getChilds().get(1)).getChilds().get(0));
                Function f = new Function(name, curr_lineno());
                m1 = new Call(obj, f, curr_lineno()); 
            }
            else{
                m1 = (Call) m;
            }   
        }
        if(arg instanceof Arguments)
            m1.addArguments((Arguments)arg);
        RESULT = m1;
    :}
    | SuperCall
    | CallExpression:c Arguments:arg
    {:
        Call m1;
        if(c instanceof ItemAccess){
            ItemAccess acc = (ItemAccess) c;
            Label obj = new Label("Callee", curr_lineno());
            obj.addChild((Node)((Node)acc.getChilds().get(0)).getChilds().get(0));
            Label name = new Label("Name", curr_lineno());
            name.addChild((Node)((Node)acc.getChilds().get(1)).getChilds().get(0));
            Function f = new Function(name, curr_lineno());
            m1 = new Call(obj, f, curr_lineno()); 
        }
        else{
            m1 = (Call) c;
        } 
        if(arg instanceof Arguments)
            m1.addArguments((Arguments)arg);
        RESULT = m1;
    :}
    | CallExpression:c LSQPAR Expression:e RSQPAR
    {:
        Label source = new Label("Source", curr_lineno());
        source.addChild((Node)c);
        Label access = new Label("Property", curr_lineno());
        access.addChild((Node)e);
        ItemAccess ia = new ItemAccess(source, access, curr_lineno());
        RESULT = ia;
    :}
    | CallExpression:c DOT IDENTIFIERNAME:fn
    {:
        Label source = new Label("Source", curr_lineno());
        source.addChild((Node)c);
        Label access = new Label("Property", curr_lineno());
        Identifier id = new Identifier(""+fn, curr_lineno());
        access.addChild((Node)id);
        ItemAccess ia = new ItemAccess(source, access, curr_lineno());
        RESULT = ia;
    :}
    ;
    
SuperCall
    ::= SUPER Arguments
    ;

Arguments
    ::= LPAR RPAR
    | LPAR ArgumentList:al RPAR
    {:
        RESULT = al;
    :}
    ;
    
ArgumentList
    ::= AssignmentExpression:ae
    {:
        Arguments a = new Arguments(curr_lineno());
        a.addChild((Node)ae);
        RESULT = a;
    :}
    | DOT3 AssignmentExpression
    | ArgumentList:al COMMA AssignmentExpression:ae
    {:
        Arguments a = (Arguments) al;
        a.addChild((Node)ae);
        RESULT = a;
    :}
    | ArgumentList COMMA DOT3 AssignmentExpression
    ;
    
LeftHandSideExpression
    ::= NewExpression:ne
    {:
        RESULT = ne;
    :}
    | CallExpression:c
    {:
        RESULT = c;
    :}
    ;

UpdateExpression
    ::= LeftHandSideExpression:lh
    {:
        RESULT = lh;
    :}
    | LeftHandSideExpression:lh DPLUS
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("PLUS", (Node)lh, (Node)me, curr_lineno());
        LateAssign as = new LateAssign((Node)lh, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | LeftHandSideExpression:lh DMINUS
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("MINUS", (Node)lh, (Node)me, curr_lineno());
        LateAssign as = new LateAssign((Node)lh, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | DPLUS UnaryExpression:ue
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("PLUS", (Node)ue, (Node)me, curr_lineno());
        Assign as = new Assign((Node)ue, (Node)op, curr_lineno());
        RESULT = as;
    :}
    | DMINUS UnaryExpression:ue
    {:
        Node me = new Literal("1", curr_lineno(), new Node("int"));
        Operation op = new Operation("MINUS", (Node)ue, (Node)me, curr_lineno());
        Assign as = new Assign((Node)ue, (Node)op, curr_lineno());
        RESULT = as;
    :}
    ;
    
UnaryExpression
    ::= UpdateExpression:ue
    {:
        RESULT = ue;
    :}
    | DELETE UnaryExpression:ue
    {:
        Operation op = new Operation("DELETE", (Node)ue, curr_lineno());
        RESULT = op;
    :}
    | VOID UnaryExpression:ue
    {:
        Operation op = new Operation("VOID", (Node)ue, curr_lineno());
        RESULT = op;
    :}
    | TYPEOF UnaryExpression:ue
    {:
        Operation op = new Operation("TYPEOF", (Node)ue, curr_lineno());
        RESULT = op;
    :}
    | PLUS UnaryExpression:ue
    {:
        Operation op = new Operation("PLUS", (Node)ue, curr_lineno());
        RESULT = op;
    :}
    | MINUS UnaryExpression:ue
    {:
        Operation op = new Operation("MINUS", (Node)ue, curr_lineno());
        RESULT = op;
    :}
    | TILDE UnaryExpression:ue
    {:
        Operation op = new Operation("FLIP BITS", (Node)ue, curr_lineno());
        RESULT = op;
    :}
    | NOT UnaryExpression:ue
    {:
        Operation op = new Operation("NOT", (Node)ue, curr_lineno());
        RESULT = op;
    :}
    ;
    
ExponentiationExpression
    ::= UnaryExpression:ue
    {:
        RESULT = ue;
    :}
    | UpdateExpression:ue DSTAR ExponentiationExpression:ee
    {:
        Operation op = new Operation("EXP", (Node)ue, (Node)ee, curr_lineno());
        RESULT = op;
    :}
    ;
    
MultiplicativeExpression
    ::= ExponentiationExpression:ee
    {:
        RESULT = ee;
    :}
    | MultiplicativeExpression:me MultiplicativeOperator:mo ExponentiationExpression:ee
    {:
        Operation op = new Operation((String)mo, (Node)me, (Node)ee, curr_lineno());
        RESULT = op;
    :}
    ;
    
MultiplicativeOperator 
    ::= STAR
    {:
        RESULT = "MULT";
    :}
    | DIV
    {:
        RESULT = "DIV";
    :}
    | MOD
    {:
        RESULT = "MOD";
    :}
    ;
    
AdditiveExpression
    ::= MultiplicativeExpression:me
    {:
        RESULT = me;
    :}
    | AdditiveExpression:ae PLUS MultiplicativeExpression:me
    {:
        Operation op = new Operation("PLUS", (Node)ae, (Node)me, curr_lineno());
        RESULT = op;
    :}
    | AdditiveExpression:ae MINUS MultiplicativeExpression:me
    {:
        Operation op = new Operation("MINUS", (Node)ae, (Node)me, curr_lineno());
        RESULT = op;
    :}
    ;
    
ShiftExpression
    ::= AdditiveExpression:ae
    {:
        RESULT = ae;
    :}
    | ShiftExpression TWOLANG AdditiveExpression
    | ShiftExpression TWORANG AdditiveExpression
    | ShiftExpression THREERANG AdditiveExpression
    ;
    
RelationalExpression
    ::= ShiftExpression:se
    {:
        RESULT = se;
    :}
    | RelationalExpression:re LT ShiftExpression:se
    {:
        Operation b = new Operation("LESS THAN", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re GT ShiftExpression:se
    {:
        Operation b = new Operation("GREATER THAN", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re LEQ ShiftExpression:se
    {:
        Operation b = new Operation("LESS THAN OR EQUAL", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re GEQ ShiftExpression:se
    {:
        Operation b = new Operation("GREATER THAN OR EQUAL", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re INSTANCEOF ShiftExpression:se
    {:
        Operation b = new Operation("INSTANCEOF", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    | RelationalExpression:re IN ShiftExpression:se
    {:
        Operation b = new Operation("IN", (Node)re, (Node)se, curr_lineno());
        RESULT = b;
    :}
    ;
    
EqualityExpression
    ::= RelationalExpression:re
    {:
        RESULT = re;
    :}
    | EqualityExpression:ee EQ RelationalExpression:re
    {:
        Operation b = new Operation("EQUAL", (Node)ee, (Node)re, curr_lineno());
        RESULT = b;
    :}
    | EqualityExpression:ee NEQ RelationalExpression:re
    {:
        Operation b = new Operation("NOT EQUAL", (Node)ee, (Node)re, curr_lineno());
        RESULT = b;
    :}
    | EqualityExpression:ee TYPEEQ RelationalExpression:re
    {:
        Operation b = new Operation("TYPE EQUAL", (Node)ee, (Node)re, curr_lineno());
        RESULT = b;
    :}
    | EqualityExpression:ee TYPENEQ RelationalExpression:re
    {:
        Operation b = new Operation("TYPE NOT EQUAL", (Node)ee, (Node)re, curr_lineno());
        RESULT = b;
    :}
    ;
    
BitwiseAndExpression
    ::= EqualityExpression:ee
    {:
        RESULT = ee;
    :}
    | BitwiseAndExpression:be AND EqualityExpression:ee
    {:
        Operation b = new Operation("BITWISE AND", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;
    
    
BitwiseXOrExpression
    ::= BitwiseAndExpression:ba
    {:
        RESULT = ba;
    :}
    | BitwiseXOrExpression:be HAT BitwiseAndExpression:ee
    {:
        Operation b = new Operation("BITWISE XOR", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;
    
BitwiseOrExpression
    ::= BitwiseXOrExpression:bx
    {:
        RESULT = bx;
    :}
    | BitwiseOrExpression:be OR BitwiseXOrExpression:ee
    {:
        Operation b = new Operation("BITWISE OR", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;

LogicalAndExpression
    ::= BitwiseOrExpression:bo
    {:
        RESULT = bo;
    :}
    | LogicalAndExpression:be LOGAND BitwiseOrExpression:ee
    {:
        Operation b = new Operation("LOGICAL AND", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;

LogicalOrExpression
    ::= LogicalAndExpression:la
    {:
        RESULT = la;
    :}
    | LogicalOrExpression:be LOGOR LogicalAndExpression:ee
    {:
        Operation b = new Operation("LOGICAL OR", (Node)be, (Node)ee, curr_lineno());
        RESULT = b;
    :}
    ;
    
ConditionalExpression
    ::= LogicalOrExpression:lo
    {:
        RESULT = lo;
    :}
    | LogicalOrExpression:lo QUESTION AssignmentExpression:ae1 COLON AssignmentExpression:ae2
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)lo);
        Label tl = new Label("Then Body", curr_lineno());
        tl.addChild((Node)ae1);
        Label el = new Label("Else Body", curr_lineno());
        el.addChild((Node)ae2);
        IfNode ifn = new IfNode(cl, tl, el, curr_lineno());
        RESULT = ifn;
    :}
    ;
    
AssignmentExpression
    ::= ConditionalExpression:ce
    {:
        RESULT = ce;
    :}
    | YieldExpression
    | LeftHandSideExpression:lh ASSIGN AssignmentExpression:ae
    {:
        Assign as = new Assign((Node)lh, (Node)ae, curr_lineno());
        RESULT = as;
    :}
    | LeftHandSideExpression:lh AssignmentOperator:ao AssignmentExpression:ae
    {:
        Operation op = new Operation((String)ao, (Node)lh, (Node)ae, curr_lineno());
        Assign as = new Assign((Node)lh, op, curr_lineno());
        RESULT = as;
    :}
    | IdentifierReference:ir Initializer:i
    {:
        Node el = (Node)i;
        if(el instanceof LateAssign){
            Node child = (Node) el.getChilds().get(0);
            Assign a = new Assign((Node)ir, child, curr_lineno());
            ArrayList<Node> list = new ArrayList<Node>();
            list.add(a);
            list.add(el);
            RESULT = list;
        }
        else{
            Assign a = new Assign((Node)ir, el, curr_lineno());
            RESULT = a;
        }
    :}
    ;


   
AssignmentOperator
    ::= STAREQ
    {:
        RESULT = "MULT";
    :}
    | DIVEQ
    {:
        RESULT = "DIV";
    :}
    | MODEQ
    {:
        RESULT = "MOD";
    :}
    | PLUSEQ
    {:
        RESULT = "PLUS";
    :}
    | MINUSEQ
    {:
        RESULT = "MINUS";
    :}
    | TWOLANGEQ
    {:
        RESULT = "LEFT_SHIFT";
    :}
    | TWORANGEQ
    {:
        RESULT = "RIGHT_SHIFT";
    :}
    | THREERANGEQ
    {:
        RESULT = "UNS_RIGHT_SHIFT";
    :}
    | ANDEQ
    {:
        RESULT = "AND";
    :}
    | OREQ
    {:
        RESULT = "OR";
    :}
    | HATEQ
    {:
        RESULT = "XOR";
    :}
    | TWOSTAREQ
    {:
        RESULT = "EXP";
    :}
    ;

Expression
    ::= AssignmentExpression:ae
    {:
        Expression<String> exp = new Expression<String>(curr_lineno());
        if (ae instanceof ArrayList){
            Iterator it = ((ArrayList) ae).iterator();
            while(it.hasNext()){
            	exp.addChild(((Node)it.next()));
            }
        }
        else{
            exp.addChild((Node)ae);
        }
        RESULT = exp;
    :}
    | Expression:e COMMA AssignmentExpression:ae
    {:
        Expression<String> exp = new Expression<String>(curr_lineno());
        if (ae instanceof ArrayList){
            Iterator it = ((ArrayList) ae).iterator();
            while(it.hasNext()){
            	exp.addChild(((Node)it.next()));
            }
        }
        else{
            exp.addChild((Node)ae);
        }
        RESULT = exp;
    :}
    ;
    
Statement
    ::= BlockStatement:bs
    {:
        RESULT = bs;
    :}
    | VariableStatement:vs
    {:
        RESULT = vs;
    :}
    | EmptyStatement
    | ExpressionStatement:es
    {:
        RESULT = es;
    :}
    | IfStatement:is
    {:
        RESULT = is;
    :}
    | BreakableStatement:bs
    {:
        RESULT = bs;
    :}
    | ContinueStatement
    {:
        Label c = new Label("CONTINUE",curr_lineno());
        RESULT = c;
    :}
    | BreakStatement
    {:
        Label b = new Label("BREAK",curr_lineno());
        RESULT = b;
    :}
    | ReturnStatement:r
    {:
        RESULT = r;
    :}
    | WithStatement
    | LabelledStatement:ls
    {:
        RESULT = ls;
    :}
    | ThrowStatement:ts
    {:
        RESULT = ts;
    :}
    | TryStatement:ty
    {:
        RESULT = ty;
    :}
    | DebuggerStatement
    ;
    
Declaration
    ::= HoistableDeclaration:hd
    {:
        RESULT = hd;
    :}
    | ClassDeclaration:cd
    {:
        RESULT = cd;
    :}
    | LexicalDeclaration:ld
    {:
        RESULT = ld;
    :}
    ;
    
HoistableDeclaration
    ::= FunctionDeclaration:fd
    {:
        RESULT = fd;
    :}
    | GeneratorDeclaration:gd
    {:
        RESULT = gd;
    :}
    ;
    
BreakableStatement
    ::= IterationStatement:is
    {:
        RESULT = is;
    :}
    | SwitchStatement:ss
    {:
        RESULT = ss;
    :}
    ;
    
BlockStatement
    ::= Block:b
    {:
        RESULT = b;
    :}
    ;
    
Block
    ::= LBPAR StatementList:sl RBPAR
    {:
        RESULT = sl;
    :}
    ;
    
StatementList
    ::= StatementListItem:sli
    {:
        StatementList list = new StatementList();
        if(sli != null){
            if (sli instanceof ArrayList){
                sli = (ArrayList<Node>)sli;
                Iterator it = ((ArrayList) sli).iterator();
                while(it.hasNext()){
                    Node current = (Node)it.next();
                    if (current instanceof Expression){
                        ArrayList<Node> childs = (ArrayList<Node>) current.getChilds();
                        Iterator it2 = childs.iterator();
                        while(it2.hasNext()){
                            list.addChild(((Node)it.next()));
                        }
                    }
                    else{
                        list.addChild(current);
                    }
                }
            }
            else{
                Node current = (Node) sli;
                if (current instanceof Expression){
                    ArrayList<Node> childs = (ArrayList<Node>) current.getChilds();
                    Iterator it2 = childs.iterator();
                    while(it2.hasNext()){
                        list.addChild(((Node)it2.next()));
                    }
                }
                else{
                    list.addChild(current);
                }
            } 
        }
        RESULT = list;
    :}
    | StatementList:sl StatementListItem:sli
    {:
        StatementList list = (StatementList)sl;
        if(sli != null){
            if (sli instanceof ArrayList){
                sli = (ArrayList<Node>)sli;
                Iterator it = ((ArrayList) sli).iterator();
                while(it.hasNext()){
                    Node current = (Node)it.next();
                    if (current instanceof Expression){
                        ArrayList<Node> childs = (ArrayList<Node>) current.getChilds();
                        Iterator it2 = childs.iterator();
                        while(it2.hasNext()){
                            list.addChild(((Node)it.next()));
                        }
                    }
                    else{
                        list.addChild(current);
                    }
                }
            }
            else{
                Node current = (Node) sli;
                if (current instanceof Expression){
                    ArrayList<Node> childs = (ArrayList<Node>) current.getChilds();
                    Iterator it2 = childs.iterator();
                    while(it2.hasNext()){
                        list.addChild(((Node)it2.next()));
                    }
                }
                else{
                    list.addChild(current);
                }
            }
        }
        RESULT = list;
    :}
    ;
    
StatementListItem
    ::= Statement:s
    {:
        RESULT = s;
    :}
    | Declaration:d
    {:
        RESULT = d;
    :}
    ;

LexicalDeclaration
    ::= LetOrConst:lc BindingList:bl
    {:
        Label l = new Label(""+lc, curr_lineno());
        Iterator it = ((ArrayList) bl).iterator();
        while(it.hasNext()){
            l.addChild(((Node)it.next()));
        }
        RESULT = l;
    :}
    ;
    
LetOrConst
    ::= LET:l
    {:
        RESULT = "LET";  
    :}
    | CONST:c
    {:
        RESULT = "CONST";
    :}
    ;
    
BindingList
    ::= LexicalBinding:lb
    {:
        ArrayList<Node> list = new ArrayList<Node>();
        list.add((Node)lb);
        RESULT = list;
    :}
    | BindingList:bl COMMA LexicalBinding:lb
    {:
        ArrayList<Node> list = ((ArrayList<Node>)bl);
        list.add((Node)lb);
        RESULT = list;
    :}
    ;
    
LexicalBinding
    ::= BindingIdentifier Initializer
    | BindingIdentifier:bi
    {:
        RESULT = bi;
    :}
    | BindingPattern Initializer
    ;
    
VariableStatement
    ::= VAR VariableDeclarationList:vl SEMI
     {:
        RESULT = vl;
    :}
    ;
    
VariableDeclarationList
    ::= VariableDeclaration:vd
    {:
        DeclarationList list = new DeclarationList();
        list.addChild((Node)vd);
        RESULT = list;
    :}
    | VariableDeclarationList:vl COMMA VariableDeclaration:vd
    {:
        ((DeclarationList)vl).addChild((Node)vd);
        RESULT = vl;
    :}
    ;
    
VariableDeclaration
    ::= BindingIdentifier:bi Initializer:i
    {:
        Assign as = new Assign((Node)bi, (Node)i, curr_lineno());
        RESULT = as;
    :}
    | BindingIdentifier:bi
    {:
        RESULT = bi;
    :}
    | BindingPattern Initializer
    ;
    
BindingPattern
    ::= ObjectBindingPattern
    | ArrayBindingPattern
    ;

ObjectBindingPattern
    ::= LBPAR RBPAR
    | LBPAR BindingPropertyList RBPAR
    | LBPAR BindingPropertyList COMMA RBPAR
    ;
    
ArrayBindingPattern
    ::= LSQPAR Elision BindingRestElement RSQPAR
    | LSQPAR Elision RSQPAR
    | LSQPAR BindingRestElement RSQPAR
    | LSQPAR RSQPAR
    | LSQPAR BindingElementList RSQPAR
    | LSQPAR BindingElementList COMMA Elision BindingRestElement RSQPAR
    | LSQPAR BindingElementList COMMA Elision RSQPAR
    | LSQPAR BindingElementList COMMA BindingRestElement RSQPAR
    | LSQPAR BindingElementList COMMA RSQPAR
    ;
    
BindingPropertyList
    ::= BindingProperty
    | BindingPropertyList COMMA BindingProperty
    ;
    
BindingElementList
    ::= BindingElisionElement
    | BindingElementList COMMA BindingElisionElement
    ;

BindingElisionElement
    ::= Elision BindingElement
    | BindingElement
    ;
    
BindingProperty
    ::= SingleNameBinding
    | PropertyName COLON BindingElement
    ;
    
BindingElement
    ::= SingleNameBinding:sn
    {:
        RESULT = sn;
    :}
    | BindingPattern Initializer
    | BindingPattern
    ;
    
SingleNameBinding
    ::= BindingIdentifier:bi Initializer:i
    {:
        Assign sn = new Assign((Node)bi, (Node)i, curr_lineno());
        RESULT = sn;
    :}
    | BindingIdentifier:bi
    {:
        RESULT = bi;
    :}
    ;
    
BindingRestElement
    ::= DOT3 BindingIdentifier
    | DOT3 BindingPattern
    ;
    
EmptyStatement
    ::= SEMI
    | COMMENT
    ;
    
ExpressionStatement
    ::= Expression:e SEMI
    {:
        RESULT = e;
    :}
    ;
    
IfStatement
    ::= IF LPAR Expression:e RPAR Statement:s1 ELSE Statement:s2
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e);
        Label tl = new Label("Then Body", curr_lineno());
        tl.addChild((Node)s1);
        Label el = new Label("Else Body", curr_lineno());
        el.addChild((Node)s2);
        IfNode ifn = new IfNode(cl, tl, el, curr_lineno());
        RESULT = ifn;
    :}
    | IF LPAR Expression:e RPAR Statement:s
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e);
        Label tl = new Label("Then Body", curr_lineno());
        tl.addChild((Node)s);
        IfNode ifn = new IfNode(cl, tl, curr_lineno());
        RESULT = ifn;
    :}
    ;
    
IterationStatement
    ::= DO Statement:s WHILE LPAR Expression:e RPAR SEMI
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        WhileOp w = new WhileOp("DO WHILE",bl, cl, curr_lineno());
        RESULT = w;
    :}
    | WHILE LPAR Expression:e RPAR Statement:s
    {:
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        WhileOp w = new WhileOp("WHILE",cl, bl, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR Expression:e1 SEMI Expression:e2 SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR Expression:e1 SEMI SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR SEMI Expression:e2 SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR SEMI SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR Expression:e1 SEMI Expression:e2 SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR Expression:e1 SEMI SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR SEMI Expression:e2 SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR SEMI SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR VariableDeclarationList:e1 SEMI Expression:e2 SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR VariableDeclarationList:e1 SEMI Expression:e2 SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild((Node)e2);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR VariableDeclarationList:e1 SEMI SEMI Expression:e3 RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ul.addChild((Node)e3);
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR VariableDeclarationList:e1 SEMI SEMI RPAR Statement:s
    {:
        Label il = new Label("Initialization", curr_lineno());
        il.addChild((Node)e1);
        Label cl = new Label("Condition", curr_lineno());
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR LexicalDeclaration Expression SEMI Expression RPAR Statement
    | FOR LPAR LexicalDeclaration Expression SEMI RPAR Statement
    | FOR LPAR LexicalDeclaration SEMI Expression RPAR Statement
    | FOR LPAR LexicalDeclaration SEMI RPAR Statement
    | FOR LPAR LeftHandSideExpression:lh IN Expression:e RPAR Statement:s
    {:
        Operation b = new Operation("IN", (Node)lh, (Node)e, curr_lineno());
        Label il = new Label("Initialization", curr_lineno());
        Label cl = new Label("Condition", curr_lineno());
        cl.addChild(b);
        Label bl = new Label("Body", curr_lineno());
        bl.addChild((Node)s);
        Label ul = new Label("Update", curr_lineno());
        ForOp w = new ForOp(il, cl, bl, ul, curr_lineno());
        RESULT = w;
    :}
    | FOR LPAR VAR ForBinding IN Expression RPAR Statement
    | FOR LPAR ForDeclaration IN Expression RPAR Statement
    | FOR LPAR LeftHandSideExpression OF AssignmentExpression RPAR Statement
    | FOR LPAR VAR ForBinding OF AssignmentExpression RPAR Statement
    | FOR LPAR ForDeclaration OF AssignmentExpression RPAR Statement
    ;
    
ForDeclaration
    ::= LetOrConst ForBinding
    ;
    
ForBinding
    ::= BindingIdentifier
    | BindingPattern
    ;
    
ContinueStatement
    ::= CONTINUE SEMI
    | CONTINUE LabelIdentifier SEMI
    ;
    
BreakStatement
    ::= BREAK SEMI
    | BREAK LabelIdentifier SEMI
    ;
    
ReturnStatement
    ::= RETURN SEMI
    {:
        Return r = new Return(curr_lineno());
        RESULT = r;
    :}
    | RETURN Expression:e SEMI
    {:
         Return r = new Return((Node)e,curr_lineno());
        RESULT = r;
    :}
    ;
    
WithStatement
    ::= WITH LPAR Expression RPAR Statement
    ;
    
SwitchStatement
    ::= SWITCH LPAR Expression:e RPAR CaseBlock:cb
    {:
        Label l = new Label("Expression", curr_lineno());
        l.addChild((Node)e);
        Switch sw = new Switch(l, curr_lineno());
        if (cb instanceof ArrayList){
            cb = (ArrayList<Node>)cb;
            Iterator it = ((ArrayList) cb).iterator();
            while(it.hasNext()){
            	sw.addChild(((Node)it.next()));
            }
        }
        else{
            if(cb != null)
                sw.addChild((Node)cb);
        }
        RESULT = sw;
    :}
    ;
    
CaseBlock
    ::= LBPAR CaseClauses:cc RBPAR
    {:
        RESULT = cc;
    :}
    | LBPAR RBPAR
    | LBPAR CaseClauses:cc DefaultCase:d CaseClauses:cc2 RBPAR
    {:
        ((ArrayList<Node>)cc).add((Node)d);
        ((ArrayList<Node>)cc).addAll((ArrayList<Node>)cc2);
        RESULT = cc;
    :}
    | LBPAR CaseClauses:cc DefaultCase:d RBPAR
    {:
        ((ArrayList<Node>)cc).add((Node)d);
        RESULT = cc;
    :}
    | LBPAR DefaultCase:d CaseClauses:cc RBPAR
    {:
        ((ArrayList<Node>)cc).add((Node)d);
        RESULT = cc;
    :}
    | LBPAR DefaultCase:d RBPAR
    {:
        RESULT = d;
    :}
    ;
    
CaseClauses
    ::= CaseClause:cc
    {:
        ArrayList<Node> list = new ArrayList<Node>();
        list.add((Node)cc);
        RESULT = list;
    :}
    | CaseClauses:cl CaseClause:cc
    {:
        ((ArrayList<Node>)cl).add((Node)cc);
        RESULT = cl;
    :}
    ;
    
CaseClause
    ::= CASE Expression:e COLON StatementList:sl
    {:
        RESULT = new Clause("CASE",  (Node)e, (Node)sl, curr_lineno());
    :}
    | CASE Expression:e COLON
    {:
        RESULT = new Clause("CASE", (Node)e, curr_lineno());
    :}
    ;
    
DefaultCase
    ::= DEFAULT COLON StatementList:sl
    {:
        RESULT = new Clause("DEFAULT", (Node)sl, curr_lineno());
    :}
    | DEFAULT COLON
    {:
        RESULT = new Clause("DEFAULT", curr_lineno());
    :}
    ;
    
LabelledStatement
    ::= LabelIdentifier:lid COLON LabelledItem:lit
    {:
        Label l = new Label("Label", curr_lineno());
        l.addChild((Node)lid);
        Label it = new Label("Item", curr_lineno());
        it.addChild((Node)lit);
        Operation op = new Operation("LABELING", l, it, curr_lineno());
        RESULT = op;
    :}
    ;
   
LabelledItem
    ::= Statement:s
    {:
        RESULT = ((Node)((Node)s).getChilds().get(0));
    :}
    | FunctionDeclaration:fd
    {:
        RESULT = fd;
    :}
    ;
    
ThrowStatement
    ::= THROW Expression:e
    {:
        ThrowNode tn = new ThrowNode((Node)e, curr_lineno());
        RESULT = tn;
    :}
    ;
    
TryStatement
    ::= TRY Block:b Catch:c
    {:
        TryStat ts = new TryStat(curr_lineno());
        Label body = new Label("Body", curr_lineno());
        body.addChild((Node)b);
        ts.addChild(body);
        ts.addChild((Node)c);
        RESULT = ts;
    :}
    | TRY Block:b Finally:f
    {:
        TryStat ts = new TryStat(curr_lineno());
        Label body = new Label("Body", curr_lineno());
        body.addChild((Node)b);
        ts.addChild(body);
        ts.addChild((Node)f);
        RESULT = ts;
    :}
    | TRY Block:b Catch:c Finally:f
    {:
        TryStat ts = new TryStat(curr_lineno());
        Label body = new Label("Body", curr_lineno());
        body.addChild((Node)b);
        ts.addChild(body);
        ts.addChild((Node)c);
        ts.addChild((Node)f);
        RESULT = ts;
    :}
    ;
    
Catch
    ::= CATCH LPAR CatchParameter:cp RPAR Block:b
    {:
        Label cat = new Label("Catch", curr_lineno());
        Label param = new Label("Parameter", curr_lineno());
        param.addChild((Node)cp);
        Label body = new Label("Body", curr_lineno());
        body.addChild((Node)b);
        cat.addChild(param);
        cat.addChild(body);
        RESULT = cat;
    :}
    ;
    
Finally
    ::= FINALLY Block:b
    {:
        Label cat = new Label("Finally", curr_lineno());
        Label body = new Label("Body", curr_lineno());
        body.addChild((Node)b);
        cat.addChild(body);
        RESULT = cat;
    :}
    ;
    
CatchParameter
    ::= BindingIdentifier:bi
    {:
        RESULT = bi;
    :}
    | BindingPattern:bp
    {:
        RESULT = bp;
    :}
    ;
    
DebuggerStatement
    ::= DEBUGGER
    ;
    
FunctionDeclaration
    ::= FUNCTION BindingIdentifier:bi LPAR FormalParameters:fp RPAR LBPAR FunctionBody:fb RBPAR
    {:
        Label name = new Label("Name", curr_lineno());
        name.addChild((Node)bi);
        Label param = new Label("Parameters", curr_lineno());
        if (fp != null){
            if (fp instanceof ArrayList){
                Iterator it = ((ArrayList)fp).iterator();
                while(it.hasNext()){
                    param.addChild(((Node)it.next()));
                }
            }
            else{ 
                param.addChild((Node)fp);
            }
        }
        Label body = new Label("Body", curr_lineno());
        if (fb != null)
            body.addChild((Node)fb);
        FunctionDeclaration f = new FunctionDeclaration(name, param, body, curr_lineno());
        RESULT = f;
    :}
    | FUNCTION LPAR FormalParameters:fp RPAR LBPAR FunctionBody:fb RBPAR
    {:
        Label name = new Label("Name", curr_lineno());
        Label param = new Label("Parameters", curr_lineno());
        if (fp != null){
            if (fp instanceof ArrayList){
                Iterator it = ((ArrayList)fp).iterator();
                while(it.hasNext()){
                    param.addChild(((Node)it.next()));
                }
            }
            else{ 
                param.addChild((Node)fp);
            }
        }
        Label body = new Label("Body", curr_lineno());
        if (fb != null)
            body.addChild((Node)fb);
        FunctionDeclaration f = new FunctionDeclaration(name, param, body, curr_lineno());
        RESULT = f;
    :}
    ;
    
FunctionExpression
    ::= FUNCTION BindingIdentifier:bi LPAR FormalParameters:fp RPAR LBPAR FunctionBody:fb RBPAR
    {:
        Label name = new Label("Name", curr_lineno());
        name.addChild((Node)bi);
        Label param = new Label("Parameters", curr_lineno());
        if (fp != null){
            if (fp instanceof ArrayList){
                Iterator it = ((ArrayList)fp).iterator();
                while(it.hasNext()){
                    param.addChild(((Node)it.next()));
                }
            }
            else{ 
                param.addChild((Node)fp);
            }
        }
        Label body = new Label("Body", curr_lineno());
        if (fb != null)
            body.addChild((Node)fb);
        FunctionDeclaration f = new FunctionDeclaration(name, param, body, curr_lineno());
        RESULT = f;
    :}
    | FUNCTION LPAR FormalParameters:fp RPAR LBPAR FunctionBody:fb RBPAR
    {:
        Label name = new Label("Name", curr_lineno());
        Label param = new Label("Parameters", curr_lineno());
        if (fp != null){
            if (fp instanceof ArrayList){
                Iterator it = ((ArrayList)fp).iterator();
                while(it.hasNext()){
                    param.addChild(((Node)it.next()));
                }
            }
            else{ 
                param.addChild((Node)fp);
            }
        }
        Label body = new Label("Body", curr_lineno());
        if (fb != null)
            body.addChild((Node)fb);
        FunctionDeclaration f = new FunctionDeclaration(name, param, body, curr_lineno());
        RESULT = f;
    :}
    ;
    
StrictFormalParameters
    ::= FormalParameters
    ;
    
FormalParameters
    ::= 
    {:
        RESULT = null;
    :}
    | FormalParameterList:fl
    {:
        RESULT = fl;
    :}
    ;
    
FormalParameterList
    ::= FunctionRestParameter
    | FormalList:fl
    {:
        RESULT = fl;
    :}
    | FormalList COMMA FunctionRestParameter
    ;
    
FormalList
    ::= FormalParameter:fp
    {:
        ArrayList<Node> list = new ArrayList<Node>();
        list.add((Node)fp);
        RESULT = list;
    :}
    | FormalList:fl COMMA FormalParameter:fp
    {:
        ArrayList<Node> list = (ArrayList<Node>)fl;
        list.add((Node)fp);
        RESULT = list;
    :}
    ;
    
FunctionRestParameter
    ::= BindingRestElement
    ;
    
FormalParameter
    ::= BindingElement:be
    {:
        RESULT = be;
    :}
    ;
    
FunctionBody
    ::= FunctionStatementList:fs
    {:
        RESULT = fs;
    :}
    ;
    
FunctionStatementList
    ::= StatementList:sl
    {:
        RESULT = sl;
    :}
    |
    ;

MethodDefinition
    ::= PropertyName LPAR StrictFormalParameters RPAR LBPAR FunctionBody RBPAR
    | GeneratorMethod
    | GET PropertyName LPAR RPAR LBPAR FunctionBody RBPAR
    | SET PropertyName LPAR PropertySetParameterList RPAR LBPAR FunctionBody RBPAR
    ;
    
PropertySetParameterList
    ::= FormalParameter
    ;
    
GeneratorMethod
    ::= STAR PropertyName LPAR StrictFormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorDeclaration
    ::= FUNCTION STAR BindingIdentifier LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    | FUNCTION STAR LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorExpression
    ::= FUNCTION STAR BindingIdentifier LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    | FUNCTION STAR LPAR FormalParameters RPAR LBPAR GeneratorBody RBPAR
    ;
    
GeneratorBody
    ::= FunctionBody
    ;

    
YieldExpression
    ::= YIELD YieldExpressionP 
    ;
    
YieldExpressionP
    ::= AssignmentExpression
    | STAR AssignmentExpression
    |
    ;